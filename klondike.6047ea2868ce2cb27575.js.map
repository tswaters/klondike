{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lib/Card.ts","webpack:///./src/redux/selectors.ts","webpack:///./src/lib/util.ts","webpack:///./src/redux/undoable.ts","webpack:///./src/redux/game-state.ts","webpack:///./src/redux/thunks.ts","webpack:///./src/components/GameCanvas.tsx","webpack:///./src/drawing/Layout.ts","webpack:///./src/redux/stacks.ts","webpack:///./src/redux/init.ts","webpack:///./src/drawing/Common.ts","webpack:///./src/drawing/FontSize.ts","webpack:///./src/hooks/useDrawing.ts","webpack:///./src/index.tsx","webpack:///./src/components/App.tsx","webpack:///./src/store.ts","webpack:///./src/redux/index.ts","webpack:///./src/components/Container.tsx","webpack:///./src/components/Fireworks.tsx","webpack:///./src/drawing/ColorScheme.ts","webpack:///./src/drawing/Card.ts","webpack:///./src/hooks/useCanvasSize.ts","webpack:///./src/components/StackElement.tsx","webpack:///./src/drawing/Stack.ts","webpack:///./src/components/TopBar.tsx","webpack:///./src/drawing/Label.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","ValueType","SuitType","StackDirection","StackType","Cards","values","suit","freeze","getStacks","createSelector","state","stacks","present","getFoundation","filter","stack","type","foundation","getTableau","tableau","getGameWon","every","cards","getHiddenCard","reduce","acc","topCard","getTopCard","hidden","stackCard","getMovableToFoundation","some","f","isValidFoundationMove","card","getStock","stock","getWaste","waste","getFoundationStack","_","find","getGameState","gameState","score","getScore","getScoringType","scoringType","getDraws","draws","getShowing","showing","getSelection","selection","disallowClickStock","rnd","Math","imul","min","max","floor","sumConsecutive","random","sameStack","stack1","stack2","index","sameCard","stackCard1","stackCard2","stackContainsCard","stackCards","item","isSequential","card1","valueToInt","isRed","diamond","heart","includes","isBlack","club","spade","isBig","ace","jack","queen","king","desintation","isValidTableauMove","destination","parseInt","destroy","UNDO","undo","REDO","redo","checkpoint","undoable","reducer","initialState","past","undefined","future","action","previous","next","newFuture","newPresent","ScoringType","ScoreType","getSavedScore","localStorage","getItem","parsed","Number","isNaN","err","saveScore","vegas","setItem","toString","getScoreChange","scoreType","regular","tableauToFoundation","wasteToFoundation","revealCard","wasteToTableau","foundationToTableau","incrementScore","decrementDraws","Infinity","INITIALIZE","MOVE_CARDS","to","from","initialize","newScoringType","dispatch","getState","availableCards","Array","performMoves","movable","checkAndPerformCardReveal","checkAndPerformFoundationMove","reveal","deselectCard","moveCards","clickCard","cardSelection","clickedCard","clickedStack","selected","selectCard","throwStock","recycleWaste","doubleClickCard","GameCtx","React","createContext","intersect","evt","pointsRef","nativeEvent","e","canvas","target","point","x","offsetX","y","offsetY","ctx","getContext","path","keys","isPointInPath","thing","GameCanvas","children","useRef","Map","clickHandlers","doubleClickHandlers","colorScheme","useState","colorSchemes","ColorSchemeType","dark","width","height","handleCanvasRef","useCanvasSize","context","useMemo","useLayoutEffect","events","current","set","onClick","onDoubleClick","delete","handleCanvasDoubleClick","useCallback","event","handleCanvasClick","id","style","backgroundColor","background","top","left","position","ref","innerWidth","innerHeight","Provider","memo","getStackCardOffsetWidth","getStackCardOffsetHeight","getVerticalMarginSize","getHorizontalMarginSize","getTopbarBox","getCardDimensions","horizontalMargin","verticalMargin","topBarBox","stackCardOffsetHeight","usedVerticalSpace","usedHorizontalSpace","maxWidth","maxHeight","getStackBox","topBar","cardLength","usedWidth","baseX","stackWidth","direction","horizontal","stackHeight","vertical","SELECT","DESELECT","REVEAL_TOP","reverse","from_card","findIndex","reducers","map","a","c2","getKey","cardCache","getHiddenImageData","getEmptyImageData","getErrorImageData","forEach","getCardImageData","document","createElement","clearRect","writeDataToCanvas","ctx2","putImageData","drawImage","allFontSizes","v","k","measureWidth","font","text","measureText","measureHeight","searchFontSize","isBigEnough","search","useDrawing","draw","gameContext","useContext","performCleanup","lastWidth","lastHeight","useEffect","add","remove","box","offline","install","applyUpdate","location","reload","ReactDOM","render","getElementById","App","store","middleware","createStore","applyMiddleware","combineReducers","hot","useDispatch","useSelector","handler","keyCode","ctrlKey","shiftKey","addEventListener","removeEventListener","button","preventDefault","fireworksObj","active","display","FireworksCanvas","ev","stop","start","emptyColor","faceUp","faceDown","buttonBorder","cardBorder","black","red","errorColor","light","FontSizeType","getBoxPath","radius","smaller","Path2D","dx","dy","dw","dh","moveTo","lineTo","quadraticCurveTo","closePath","getGlyphLocations","cardWidth","cardHeight","gutterHeight","gutterWidth","cornerWidth","figureOutFontSize","Corner","fontSizes","Regular","cornerValueX","cornerValueY","cornerSuitX","cornerSuitY","positions","glyph","rotated","textAlign","textBaseline","pos","three","five","nine","two","four","six","seven","eight","ten","getTop","getLeft","getTextAlign","fillStyle","fillRect","lineWidth","strokeStyle","strokeRect","getImageData","stroke","fill","save","translate","rotate","PI","fillText","restore","setCanvas","getSize","size","setSize","tid","handleSize","clearTimeout","setTimeout","StackElement","drawingOpts","getStackDrawingContext","prop","space","drawStack","opts","rect","empty","error","elements","drawing","TopBar","currentScore","otherGameType","deets","newGame","getLabelDrawingContext","padding","label","border","switchGame","version","handleNewGame","handleSwitchGame","drawLabel","boxHeight","beginPath","clip"],"mappings":"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","file":"klondike.6047ea2868ce2cb27575.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([23,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export enum ValueType {\n  ace = 'A',\n  two = '2',\n  three = '3',\n  four = '4',\n  five = '5',\n  six = '6',\n  seven = '7',\n  eight = '8',\n  nine = '9',\n  ten = '10',\n  jack = 'J',\n  queen = 'Q',\n  king = 'K',\n}\n\nexport enum SuitType {\n  heart = '\\u2665',\n  diamond = '\\u2666',\n  spade = '\\u2660',\n  club = '\\u2663',\n}\n\nexport type Card = {\n  suit: SuitType\n  value: ValueType\n}\n\nexport type StackCard = {\n  card: Card\n  hidden?: boolean\n  selected?: boolean\n}\n\nexport enum StackDirection {\n  horizontal = 'horizontal',\n  vertical = 'vertical',\n}\n\n//\n//  1 2   3 3 3 3\n//  4 4 4 4 4 4 4\n//\n// 1 - stock\n// 2 - waste\n// 3 - foundation\n// 4 - tableau\n//\n\nexport enum StackType {\n  tableau = 'tableau',\n  foundation = 'foundation',\n  stock = 'stock',\n  waste = 'waste',\n}\n\nexport type Stack = {\n  cards: StackCard[]\n  selection: StackCard | null\n  type: StackType\n  direction: StackDirection | null\n  index: number\n}\n\nconst Cards: Card[] = []\n\nfor (const value of Object.values(ValueType)) {\n  for (const suit of Object.values(SuitType)) {\n    Cards.push({ suit, value })\n  }\n}\n\nObject.freeze(Cards)\n\nexport { Cards }\n","import { createSelector } from 'reselect'\nimport { StoreState } from './index'\nimport { Card, Stack, StackType, StackCard } from '../lib/Card'\nimport { getTopCard, isValidFoundationMove } from '../lib/util'\n\nexport type CardSelection = { stackCard?: StackCard; stack: Stack }\n\nexport const getStacks = createSelector(\n  (state: StoreState) => state.stacks.present.stacks,\n  (stacks) => stacks,\n)\n\nconst getFoundation = createSelector(getStacks, (stacks) =>\n  stacks.filter((stack) => stack.type === StackType.foundation),\n)\n\nconst getTableau = createSelector(getStacks, (stacks) => stacks.filter((stack) => stack.type === StackType.tableau))\n\nexport const getGameWon = createSelector(getFoundation, (foundation) =>\n  foundation.every((stack) => stack.cards.length === 13),\n)\n\nexport const getHiddenCard = createSelector(getTableau, (stacks) =>\n  stacks.reduce<CardSelection | null>((acc, stack) => {\n    if (acc) return acc\n    const topCard = getTopCard(stack.cards)\n    if (topCard && topCard.hidden) return { stack, stackCard: topCard }\n    return null\n  }, null),\n)\n\nexport const getMovableToFoundation = createSelector([getStacks, getFoundation], (stacks, foundation) =>\n  stacks\n    .filter((stack) => stack.type !== StackType.foundation)\n    .reduce<CardSelection | null>((acc, stack) => {\n      if (acc) return acc\n      const topCard = getTopCard(stack.cards)\n      if (topCard == null || topCard.hidden) return acc\n      if (foundation.some((f) => isValidFoundationMove(topCard.card, getTopCard(f.cards))))\n        return { stack, stackCard: topCard }\n      return null\n    }, null),\n)\n\nexport const getStock = createSelector(\n  getStacks,\n  (stacks) => stacks.filter((stack) => stack.type === StackType.stock)[0],\n)\n\nexport const getWaste = createSelector(\n  getStacks,\n  (stacks) => stacks.filter((stack) => stack.type === StackType.waste)[0],\n)\n\nexport const getFoundationStack = createSelector(\n  getFoundation,\n  (_: unknown, card: Card) => card,\n  (foundation, card) => foundation.find((stack) => isValidFoundationMove(card, getTopCard(stack.cards))),\n)\n\nexport const getGameState = createSelector(\n  (state: StoreState) => state.gameState.present,\n  (score) => score,\n)\n\nexport const getScore = createSelector(getGameState, (score) => score.score)\n\nexport const getScoringType = createSelector(getGameState, (score) => score.scoringType)\n\nexport const getDraws = createSelector(getGameState, ({ draws }) => draws)\n\nexport const getShowing = createSelector(getGameState, ({ showing }) => showing)\n\nexport const getSelection = createSelector(getStacks, (stacks) => {\n  const stack = stacks.find((stack) => stack.selection != null)\n  if (stack) return { stackCard: stack.selection as StackCard, stack: stack }\n  return null\n})\n\nexport const disallowClickStock = createSelector(\n  [getStock, getDraws],\n  (stock, draws) => stock.cards.length === 0 && draws === 0,\n)\n","import { Card, ValueType, SuitType, Stack, StackCard } from './Card'\n\n// minstd_rand\nexport const rnd = (s: number) => {\n  const rnd = () => ((2 ** 31 - 1) & (s = Math.imul(48271, s))) / 2 ** 31\n  rnd() // first call is always junk\n  return (min: number, max: number) => Math.floor(rnd() * (max - min + 1)) + min\n}\n\nexport const sumConsecutive = (i: number) => (i * (i + 1)) / 2\n\nexport const getTopCard = (cards: StackCard[]): StackCard | null => cards[cards.length - 1]\n\nexport const random = (min: number, max: number): number => Math.floor(Math.random() * max) + min\n\n// for simplicity, these routines would just use strict object comparison\n// however, if doing that, any changes to the store in a thunk would invalidate variable reference\n// this is useful for comparing a selected, or checking if stacks are the same before modifying them\n// so, we compare both value/suit when doing card comparisons, and type/index for stack comparisons\n\nexport const sameStack = (stack1: Stack, stack2: Stack) => stack1.type === stack2.type && stack1.index === stack2.index\n\nexport const sameCard = (stackCard1: StackCard, stackCard2: StackCard) =>\n  stackCard1.card.value === stackCard2.card.value && stackCard1.card.suit === stackCard2.card.suit\n\nexport const stackContainsCard = (stackCards: StackCard[], stackCard: StackCard) =>\n  stackCards.some((item: StackCard) => sameCard(item, stackCard))\n\nexport const isSequential = (card: Card, card1: Card) => valueToInt(card1.value) + 1 === valueToInt(card.value)\n\nexport const isRed = (card: Card) => [SuitType.diamond, SuitType.heart].includes(card.suit)\n\nexport const isBlack = (card: Card) => [SuitType.club, SuitType.spade].includes(card.suit)\n\nexport const isBig = (card: Card) =>\n  [ValueType.ace, ValueType.jack, ValueType.queen, ValueType.king].includes(card.value)\n\nexport const isValidFoundationMove = (card: Card, desintation: StackCard | null) =>\n  desintation == null\n    ? card.value === ValueType.ace\n    : desintation.card.suit === card.suit && isSequential(card, desintation.card)\n\nexport const isValidTableauMove = (card: Card, destination?: StackCard) => {\n  return destination == null\n    ? card.value === ValueType.king\n    : isSequential(destination.card, card) &&\n        ((isRed(card) && isBlack(destination.card)) || (isBlack(card) && isRed(destination.card)))\n}\n\nconst valueToInt = (value: ValueType): number => {\n  if (value === ValueType.ace) return 1\n  if (value === ValueType.jack) return 11\n  if (value === ValueType.queen) return 12\n  if (value === ValueType.king) return 13\n  return parseInt(value, 10)\n}\n","import { Reducer, AnyAction } from 'redux'\n\nexport type History<State> = {\n  past: State[]\n  present: State\n  future: State[]\n}\n\nconst DESTROY = '@@undoable/destroy'\nexport type DestroyAction = { type: typeof DESTROY }\nexport const destroy = (): DestroyAction => ({ type: DESTROY })\n\nconst UNDO = '@@undoable/undo'\ntype UndoAction = { type: typeof UNDO }\nexport const undo = (): UndoAction => ({ type: UNDO })\n\nconst REDO = '@@undoable/redo'\ntype RedoAction = { type: typeof REDO }\nexport const redo = (): RedoAction => ({ type: REDO })\n\nconst CHECKPOINT = '@@undoable/checkpoint'\ntype CheckpointAction = { type: typeof CHECKPOINT }\nexport const checkpoint = (): CheckpointAction => ({ type: CHECKPOINT })\n\nexport type UndoableActions = DestroyAction | UndoAction | RedoAction | CheckpointAction\n\nexport const undoable = <S, A extends AnyAction = UndoableActions>(reducer: Reducer<S, A>) => {\n  const initialState: History<S> = {\n    past: [],\n    present: reducer(undefined, {} as A),\n    future: [],\n  }\n\n  return (state = initialState, action: A) => {\n    const { past, present, future } = state\n\n    if (action.type === UNDO) {\n      const previous = past[past.length - 1]\n      if (!previous) {\n        return state\n      }\n\n      const newPast = past.slice(0, past.length - 1)\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future],\n      }\n    }\n\n    if (action.type === REDO) {\n      const next = future[0]\n      if (!next) {\n        return state\n      }\n\n      const newFuture = future.slice(1)\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture,\n      }\n    }\n\n    const newPresent = reducer(present, action)\n\n    if (action.type === DESTROY) {\n      return {\n        past: [],\n        present: newPresent,\n        future: [],\n      }\n    }\n\n    if (action.type === CHECKPOINT) {\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: [],\n      }\n    }\n\n    if (present === newPresent) {\n      return state\n    }\n\n    return {\n      past,\n      present: newPresent,\n      future,\n    }\n  }\n}\n","import { MOVE_CARDS } from './stacks'\nimport { StackType } from '../lib/Card'\nimport { StoreActions } from '.'\nimport { undoable } from './undoable'\nimport { INITIALIZE, InitializeAction } from './init'\n\nexport enum ScoringType {\n  vegas,\n  regular,\n}\n\nexport enum ScoreType {\n  wasteToTableau = 'wasteToTableau',\n  wasteToFoundation = 'wasteToFoundation',\n  tableauToFoundation = 'tableauToFoundation',\n  revealCard = 'revealCard',\n  foundationToTableau = 'foundationToTableau',\n}\n\nexport type GameStateStore = {\n  score: number\n  showing: number\n  draws: number\n  scoringType: ScoringType\n}\n\nconst getSavedScore = (): number => {\n  try {\n    const score = localStorage.getItem('score')\n    if (score == null) return 0\n    const parsed = parseInt(score, 10)\n    if (Number.isNaN(parsed)) return 0\n    return parsed\n  } catch (err) {\n    return 0\n  }\n}\n\nexport const saveScore = (state: GameStateStore): void => {\n  try {\n    if (state.scoringType === ScoringType.vegas) {\n      localStorage.setItem('score', state.score.toString())\n    }\n  } catch (err) {\n    // ehh, that sucks\n  }\n}\n\nconst getScoreChange = (scoringType: ScoringType, scoreType: ScoreType) => {\n  let score = 0\n  if (scoringType === ScoringType.regular && scoreType === ScoreType.tableauToFoundation) {\n    score = 10\n  } else if (\n    scoreType === ScoreType.wasteToFoundation ||\n    (scoringType === ScoringType.vegas && scoreType === ScoreType.tableauToFoundation) ||\n    (scoringType === ScoringType.regular && scoreType === ScoreType.revealCard) ||\n    (scoringType === ScoringType.regular && scoreType === ScoreType.wasteToTableau)\n  ) {\n    score = 5\n  } else if (scoringType === ScoringType.regular && ScoreType.foundationToTableau) {\n    score = -10\n  } else if (scoringType === ScoringType.vegas && scoreType === ScoreType.foundationToTableau) {\n    score = -5\n  }\n  return score\n}\n\nconst INCREMENT_SCORE = '@@game-state/increment-score'\ntype IncrementScoreAction = { type: typeof INCREMENT_SCORE; scoreType: ScoreType }\nexport const incrementScore = (scoreType: ScoreType): IncrementScoreAction => ({ type: INCREMENT_SCORE, scoreType })\n\nconst DECREMENT_DRAWS = 'DECREMENT_DRAWS'\ntype DecrementDrawsAction = { type: typeof DECREMENT_DRAWS }\nexport const decrementDraws = (): DecrementDrawsAction => ({ type: DECREMENT_DRAWS })\n\nexport type GameStateActions = DecrementDrawsAction | IncrementScoreAction | InitializeAction\n\nconst initialState: GameStateStore = {\n  showing: 0,\n  score: 0,\n  draws: Infinity,\n  scoringType: ScoringType.regular,\n}\n\nconst reducer = (state: GameStateStore = initialState, action: StoreActions): GameStateStore => {\n  if (action.type === INITIALIZE) {\n    return {\n      ...state,\n      scoringType: action.scoringType,\n      score: action.scoringType === ScoringType.vegas ? getSavedScore() - 52 : 0,\n      draws: action.scoringType === ScoringType.vegas ? 2 : Infinity,\n    }\n  }\n\n  if (action.type === DECREMENT_DRAWS) {\n    return {\n      ...state,\n      draws: state.draws - 1,\n    }\n  }\n\n  if (action.type === MOVE_CARDS) {\n    return action.to.type === StackType.waste || (action.from && action.from.type === StackType.waste)\n      ? {\n          ...state,\n          showing:\n            action.to.type === StackType.waste\n              ? Math.min(action.to.cards.length + action.cards.length, 3)\n              : Math.max(1, state.showing - 1),\n        }\n      : state\n  }\n\n  if (action.type === INCREMENT_SCORE) {\n    return {\n      ...state,\n      score: state.score + getScoreChange(state.scoringType, action.scoreType),\n    }\n  }\n  return state\n}\n\nexport default undoable(reducer)\n","import { ThunkAction, ThunkDispatch as ReduxThunkDispatch } from 'redux-thunk'\n\nimport { StoreState, StoreActions } from '.'\nimport { isValidTableauMove, random } from '../lib/util'\nimport { StackType, Card, Cards } from '../lib/Card'\n\nimport { moveCards, deselectCard, selectCard, reveal, throwStock, recycleWaste } from './stacks'\nimport {\n  getSelection,\n  getFoundationStack,\n  disallowClickStock,\n  getWaste,\n  getStock,\n  getScoringType,\n  getMovableToFoundation,\n  CardSelection,\n  getHiddenCard,\n} from './selectors'\nimport { checkpoint } from './undoable'\nimport { incrementScore, ScoreType, ScoringType, decrementDraws } from './game-state'\nimport { initialize as initializeGame } from './init'\n\nexport type ThunkResult<R, E = null> = ThunkAction<R, StoreState, E, StoreActions>\nexport type ThunkDispatch<E = null> = ReduxThunkDispatch<StoreState, E, StoreActions>\n\ninterface CardClickAction<T = void> {\n  (selection: CardSelection): ThunkResult<T>\n}\n\nexport const initialize = (newScoringType?: ScoringType): ThunkResult<void> => (dispatch, getState) => {\n  const scoringType = newScoringType == null ? getScoringType(getState()) : newScoringType\n  const availableCards = Array.from(Cards)\n  const cards: Card[] = []\n\n  for (let i = 0; i < 52; i++) {\n    const index = random(0, availableCards.length)\n    cards.push(...availableCards.splice(index, 1))\n  }\n\n  dispatch(initializeGame(scoringType, cards))\n}\n\nexport const performMoves = (): ThunkResult<void> => (dispatch, getState) => {\n  let movable: CardSelection | null\n  while ((movable = getMovableToFoundation(getState()) || getHiddenCard(getState()))) {\n    if (movable.stackCard?.hidden ?? false) {\n      dispatch(checkAndPerformCardReveal(movable))\n    } else {\n      dispatch(checkAndPerformFoundationMove(movable))\n    }\n  }\n}\n\nconst checkAndPerformCardReveal: CardClickAction = (selection) => (dispatch) => {\n  if (selection == null) return\n  dispatch(checkpoint())\n  dispatch(incrementScore(ScoreType.revealCard))\n  dispatch(reveal(selection.stack))\n}\n\nconst checkAndPerformFoundationMove: CardClickAction = (selection) => (dispatch, getState) => {\n  const foundation = (selection.stackCard && getFoundationStack(getState(), selection.stackCard.card)) || null\n  if (foundation && selection.stackCard) {\n    dispatch(deselectCard())\n    dispatch(checkpoint())\n    if (selection.stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToFoundation))\n    if (selection.stack.type === StackType.tableau) dispatch(incrementScore(ScoreType.tableauToFoundation))\n    dispatch(moveCards(selection.stack, foundation, selection.stackCard))\n  }\n}\n\nexport const clickCard: CardClickAction = (cardSelection) => (dispatch, getState) => {\n  const { stackCard: clickedCard, stack: clickedStack } = cardSelection\n  if (clickedCard != null && clickedCard.selected) return dispatch(deselectCard())\n\n  const selection = getSelection(getState())\n  if (selection == null && clickedCard && !clickedCard.hidden) return dispatch(selectCard(clickedStack, clickedCard))\n\n  if (clickedStack.type === StackType.foundation && selection) {\n    dispatch(checkAndPerformFoundationMove(selection))\n    return\n  }\n\n  if (clickedStack.type === StackType.tableau) {\n    if (selection == null && clickedCard && clickedCard.hidden) {\n      dispatch(checkpoint())\n      dispatch(incrementScore(ScoreType.revealCard))\n      dispatch(reveal(clickedStack))\n    }\n    if (selection && selection.stackCard && isValidTableauMove(selection.stackCard.card, clickedCard)) {\n      dispatch(deselectCard())\n      dispatch(checkpoint())\n      if (selection.stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToTableau))\n      if (selection.stack.type === StackType.foundation) dispatch(incrementScore(ScoreType.foundationToTableau))\n      dispatch(moveCards(selection.stack, clickedStack, selection.stackCard))\n    }\n  }\n\n  if (clickedStack.type === StackType.stock) {\n    if (disallowClickStock(getState())) return\n    if (selection) dispatch(deselectCard())\n    const waste = getWaste(getState())\n    const stock = getStock(getState())\n    dispatch(checkpoint())\n    if (stock.cards.length > 0) {\n      dispatch(throwStock(stock, waste))\n    } else {\n      dispatch(recycleWaste(waste, stock))\n      dispatch(decrementDraws())\n    }\n  }\n}\n\nexport const doubleClickCard: CardClickAction = (cardSelection) => (dispatch) => {\n  const { stack, stackCard } = cardSelection\n  if (\n    stack.type === StackType.foundation ||\n    stack.type === StackType.stock ||\n    stackCard == null ||\n    stackCard.card == null\n  ) {\n    return\n  }\n\n  dispatch(checkAndPerformFoundationMove({ stack, stackCard }))\n}\n","import * as React from 'react'\nimport { Drawable, DrawingContext, Clickable, Handler } from '../drawing/Common'\nimport { ColorSchemeType, ColorScheme, colorSchemes } from '../drawing/ColorScheme'\nimport { initialize } from '../drawing/Common'\nimport { useCanvasSize } from '../hooks/useCanvasSize'\n\nexport type GameContext = {\n  context: DrawingContext\n  add: (thing: Drawable, events: Clickable) => void\n  remove: (path: Path2D) => void\n}\n\nexport const GameCtx = React.createContext<GameContext | null>(null)\n\nconst intersect = (evt: React.MouseEvent<HTMLCanvasElement>, pointsRef: Map<Path2D, Drawable>) => {\n  const { nativeEvent: e } = evt\n  const canvas = e.target as HTMLCanvasElement\n  const point = { x: e.offsetX, y: e.offsetY }\n  const ctx = canvas.getContext('2d')\n  for (const path of pointsRef.keys())\n    if (ctx?.isPointInPath(path, point.x, point.y)) {\n      const thing = pointsRef.get(path)\n      if (thing == null) return\n      return { thing, point }\n    }\n}\n\nconst GameCanvas: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const pointsRef = React.useRef<Map<Path2D, Drawable>>(new Map())\n  const clickHandlers = React.useRef<Map<Path2D, Handler>>(new Map())\n  const doubleClickHandlers = React.useRef<Map<Path2D, Handler>>(new Map())\n\n  const [colorScheme] = React.useState<ColorScheme>(colorSchemes[ColorSchemeType.dark])\n  const { ctx, width, height, handleCanvasRef } = useCanvasSize()\n\n  const context = React.useMemo<DrawingContext | null>(() => {\n    if (!width || !height || !ctx) return null\n    return { ctx, width, height, colorScheme }\n  }, [ctx, width, height, colorScheme])\n\n  React.useLayoutEffect(() => (context && initialize(context)) || void 0, [context])\n\n  const value = React.useMemo<GameContext | null>(\n    () =>\n      context && {\n        context,\n        add(thing, events) {\n          pointsRef.current.set(thing.path, thing)\n          if (events.onClick) clickHandlers.current.set(thing.path, events.onClick)\n          if (events.onDoubleClick) doubleClickHandlers.current.set(thing.path, events.onDoubleClick)\n        },\n        remove(path: Path2D) {\n          pointsRef.current.delete(path)\n          clickHandlers.current.delete(path)\n          doubleClickHandlers.current.delete(path)\n        },\n      },\n    [context],\n  )\n\n  const handleCanvasDoubleClick = React.useCallback((evt: React.MouseEvent<HTMLCanvasElement>) => {\n    const selection = intersect(evt, pointsRef.current)\n    if (selection) {\n      const { thing, point } = selection\n      const event = doubleClickHandlers.current.get(thing.path)\n      if (event) event(thing, point)\n    }\n  }, [])\n\n  const handleCanvasClick = React.useCallback((evt: React.MouseEvent<HTMLCanvasElement>) => {\n    const selection = intersect(evt, pointsRef.current)\n    if (selection) {\n      const { thing, point } = selection\n      const event = clickHandlers.current.get(thing.path)\n      if (event) event(thing, point)\n    }\n  }, [])\n\n  return (\n    <>\n      <canvas\n        id=\"canvas\"\n        style={{\n          backgroundColor: colorScheme.background,\n          top: '0',\n          left: '0',\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n        }}\n        ref={handleCanvasRef}\n        width={window.innerWidth}\n        height={window.innerHeight}\n        onClick={handleCanvasClick}\n        onDoubleClick={handleCanvasDoubleClick}\n      />\n      <GameCtx.Provider value={value}>{children}</GameCtx.Provider>\n    </>\n  )\n}\n\nexport { GameCanvas }\nexport default React.memo(GameCanvas)\n","import { DrawingContext, Box, Dimensions } from './Common'\nimport { Stack, StackDirection, StackType } from '../lib/Card'\n\nexport const getStackCardOffsetWidth = (ctx: DrawingContext) => Math.floor(ctx.height * 0.03)\n\nexport const getStackCardOffsetHeight = (ctx: DrawingContext) => Math.floor(ctx.height * 0.03)\n\nexport const getVerticalMarginSize = (ctx: DrawingContext) => Math.floor(ctx.height * 0.01)\n\nexport const getHorizontalMarginSize = (ctx: DrawingContext) => Math.floor(ctx.width * 0.01)\n\nexport const getTopbarBox = (): Box => ({ x: 0, y: 0, width: 0, height: 30 })\n\n// the goal is to find the highest possible card width/height satisfying the desired ratio\n// assuming a fixed top-bar height with no margin, ( it will account for its own padding )\n// and 1 vertical separator + 6 horizontal separators\n// also, need room to stack 13 stack + 6 hidden => 19 cards.\n// without exceeding the size of the window.\n\nexport const getCardDimensions = (ctx: DrawingContext): Dimensions => {\n  const horizontalMargin = getHorizontalMarginSize(ctx)\n  const verticalMargin = getVerticalMarginSize(ctx)\n  const topBarBox = getTopbarBox()\n  const stackCardOffsetHeight = getStackCardOffsetHeight(ctx)\n\n  const usedVerticalSpace = topBarBox.height + verticalMargin * 2 + stackCardOffsetHeight * 19\n  const usedHorizontalSpace = horizontalMargin * 6\n\n  const maxWidth = Math.floor((ctx.width - usedHorizontalSpace) / 7)\n  const maxHeight = Math.floor((ctx.height - usedVerticalSpace) / 1.5)\n\n  const DESIRED_RATIO = 1.618 // try to get golden ratio size cards\n  const width = maxWidth * DESIRED_RATIO < maxHeight ? maxWidth : maxHeight / DESIRED_RATIO\n  const height = maxWidth * DESIRED_RATIO < maxHeight ? maxWidth * DESIRED_RATIO : maxHeight\n\n  return {\n    width: Math.floor(width),\n    height: Math.floor(height),\n  }\n}\n\nexport const getStackBox = (ctx: DrawingContext, stack: Stack, max: number): Box => {\n  const verticalMargin = getVerticalMarginSize(ctx)\n  const horizontalMargin = getHorizontalMarginSize(ctx)\n  const topBar = getTopbarBox()\n  const { width, height } = getCardDimensions(ctx)\n  const cardLength = Math.min(stack.cards.length, max)\n\n  // we know horizontal space used\n  // it might be less than available width\n  // base x width is half that available space (for centering)\n\n  const usedWidth = horizontalMargin * 6 + width * 7\n  const baseX = usedWidth < ctx.width ? (ctx.width - usedWidth) / 2 : 0\n\n  const stackWidth =\n    stack.direction === StackDirection.horizontal\n      ? cardLength === 0\n        ? height\n        : getStackCardOffsetWidth(ctx) * (cardLength - 1) + width\n      : width\n\n  const stackHeight =\n    stack.direction === StackDirection.vertical\n      ? cardLength === 0\n        ? height\n        : getStackCardOffsetHeight(ctx) * (cardLength - 1) + height\n      : height\n\n  switch (stack.type) {\n    case StackType.stock:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX,\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.waste:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX + horizontalMargin + width,\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.foundation:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX + 3 * horizontalMargin + 3 * width + stack.index * (horizontalMargin + width),\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.tableau:\n      return {\n        y: topBar.height + verticalMargin * 3 + height,\n        x: baseX + stack.index * (horizontalMargin + width),\n        width: stackWidth,\n        height: stackHeight,\n      }\n  }\n}\n","import { Stack, StackCard, StackType, StackDirection } from '../lib/Card'\nimport { stackContainsCard, sumConsecutive, sameStack, sameCard } from '../lib/util'\nimport { undoable } from './undoable'\nimport { INITIALIZE, InitializeAction } from './init'\n\nexport const SELECT = '@@global/select-card'\nexport type SelectAction = { type: typeof SELECT; stack: Stack; card: StackCard }\nexport const selectCard = (stack: Stack, card: StackCard): SelectAction => ({ type: SELECT, card, stack })\n\nexport const DESELECT = '@@global/deselect-card'\nexport type DeselectAction = { type: typeof DESELECT }\nexport const deselectCard = (): DeselectAction => ({ type: DESELECT })\n\nexport const REVEAL_TOP = '@@global/reveal-top'\nexport type RevealTopCardAction = { type: typeof REVEAL_TOP; stack: Stack }\nexport const reveal = (stack: Stack): RevealTopCardAction => ({ type: REVEAL_TOP, stack })\n\nexport const MOVE_CARDS = '@@global/move-cards'\nexport type MoveCardAction = { type: typeof MOVE_CARDS; from?: Stack; to: Stack; cards: StackCard[]; hidden: boolean }\n\n// move 3 cards from the stock to the waste\nexport const throwStock = (stock: Stack, waste: Stack): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from: stock,\n  to: waste,\n  cards: stock.cards.slice(-3).reverse(),\n  hidden: false,\n})\n\n// move all cards from waste back to the stock\nexport const recycleWaste = (waste: Stack, stock: Stack): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from: waste,\n  to: stock,\n  cards: waste.cards.slice(0),\n  hidden: true,\n})\n\n// other general moves\nexport const moveCards = (from: Stack, to: Stack, from_card: StackCard | null): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from,\n  to,\n  cards: from.cards.slice(from.cards.findIndex((card) => card.card === from_card?.card || null)),\n  hidden: false,\n})\n\nexport type CardActions = SelectAction | DeselectAction | RevealTopCardAction | MoveCardAction\n\nconst reducers: {\n  [key: string]: (state: StackStore, action: CardActions | InitializeAction) => StackStore\n} = {\n  [INITIALIZE]: (state, action: InitializeAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) => {\n      switch (stack.type) {\n        case StackType.foundation:\n        case StackType.waste:\n          return { ...stack, cards: [] }\n        case StackType.stock:\n          return { ...stack, cards: action.cards.slice(0, 24).map((card) => ({ card, hidden: true })) }\n        case StackType.tableau:\n          return {\n            ...stack,\n            cards: action.cards\n              .slice(24 + sumConsecutive(stack.index), 24 + sumConsecutive(stack.index) + stack.index + 1)\n              .map((card, index, a) => ({ card, hidden: a.length !== index + 1 })),\n          }\n      }\n    }),\n  }),\n  [SELECT]: (state, action: SelectAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      sameStack(stack, action.stack) && stackContainsCard(stack.cards, action.card)\n        ? {\n            ...stack,\n            selection: action.card,\n            cards: stack.cards.map((stackCard) =>\n              !sameCard(stackCard, action.card) ? stackCard : { ...stackCard, selected: true },\n            ),\n          }\n        : stack,\n    ),\n  }),\n  [DESELECT]: (state) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      stack.selection != null\n        ? {\n            ...stack,\n            selection: null,\n            cards: stack.cards.map((stackCard) =>\n              !stackCard.selected ? stackCard : { ...stackCard, selected: false },\n            ),\n          }\n        : stack,\n    ),\n  }),\n  [MOVE_CARDS]: (state, action: MoveCardAction) =>\n    state.stacks.some((stack) => [action.from, action.to].includes(stack))\n      ? {\n          ...state,\n          stacks: state.stacks.map((stack) =>\n            sameStack(stack, action.to)\n              ? {\n                  ...stack,\n                  cards: [\n                    ...stack.cards,\n                    ...action.cards.map((card) => ({ ...card, selected: false, hidden: action.hidden })),\n                  ],\n                }\n              : action.from && sameStack(stack, action.from)\n              ? {\n                  ...stack,\n                  cards: stack.cards.filter((stackCard) => !stackContainsCard(action.cards, stackCard)),\n                }\n              : stack,\n          ),\n        }\n      : state,\n  [REVEAL_TOP]: (state, action: RevealTopCardAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      sameStack(stack, action.stack)\n        ? {\n            ...stack,\n            cards: stack.cards.map((card, index) =>\n              index < stack.cards.length - 1 ? card : { ...card, hidden: false },\n            ),\n          }\n        : stack,\n    ),\n  }),\n}\n\nexport type StackStore = {\n  readonly stacks: Stack[]\n}\n\nconst initialState: StackStore = {\n  stacks: [\n    {\n      type: StackType.stock,\n      direction: null,\n      cards: [],\n      index: 0,\n      selection: null,\n    },\n    {\n      type: StackType.waste,\n      direction: StackDirection.horizontal,\n      cards: [],\n      index: 0,\n      selection: null,\n    },\n    ...Array.from<number, Stack>({ length: 7 }, (_, index) => ({\n      index,\n      type: StackType.tableau,\n      direction: StackDirection.vertical,\n      cards: [],\n      selection: null,\n    })),\n    ...Array.from<number, Stack>({ length: 4 }, (_, index) => ({\n      index,\n      type: StackType.foundation,\n      direction: null,\n      cards: [],\n      selection: null,\n    })),\n  ],\n}\n\nconst reducer = (state: StackStore = initialState, action: CardActions): StackStore => {\n  const r = reducers[action.type]\n  if (r) return r(state, action)\n  return state\n}\n\nexport default undoable(reducer)\n","import { ScoringType } from './game-state'\nimport { Card } from '../lib/Card'\n\n// this is in it's own file because circular dependencies are jerks.\n\nexport const INITIALIZE = '@@game-state/initialize'\nexport type InitializeAction = { type: typeof INITIALIZE; scoringType: ScoringType; cards: Card[] }\nexport const initialize = (scoringType: ScoringType, cards: Card[]): InitializeAction => ({\n  type: INITIALIZE,\n  scoringType,\n  cards,\n})\n","import { Cards, StackCard } from '../lib/Card'\nimport { ColorScheme } from './ColorScheme'\nimport { getErrorImageData, getEmptyImageData, getHiddenImageData, getCardImageData } from './Card'\nimport { getCardDimensions } from './Layout'\n\n// this is passed to all drawing routines. it includes :\n// the color they should draw,\n// the ctx to draw it on, and\n// the width/height of the canvas.\n\nexport type DrawingContext = { ctx: CanvasRenderingContext2D; colorScheme: ColorScheme } & Dimensions\n\nexport type Dimensions = { width: number; height: number }\n\nexport type Point = { x: number; y: number }\n\nexport type Box = Dimensions & Point\n\n// something that is drawable includes an x/y coords and a height/width\n// once removed, clearRect is with these values to clean it from the canvas\n// also, the click/double click handlers will inspect if point is in their path.\n\nexport type Drawable = { path: Path2D; box: Box }\n\n// a draw routine takes drawing context above, and include whatever options they want\n// they perform mutations to the cavas (draw the thing) and return a drawable for tracking (above)\n\nexport interface DrawRoutine<DrawingOpts> {\n  (context: DrawingContext, arg1: DrawingOpts | null): Drawable | null\n}\n\nexport interface Handler {\n  (arg0: Drawable, arg1: Point): void\n}\n\nexport type Clickable = { onClick?: Handler; onDoubleClick?: Handler }\n\n// a cache of cards is kept and re-initialized when color scheme / window dimensions change\n// this is a map of a key identifying the stack card, and the raw pixel data to draw it.\n// the idea is this is all cached one time at the beginning and re-used\n\n// this uses a string with keys because it's actually a \"StackCard\" we're interested in\n// this includes the selected flag - the highlighted / non-highlighted state need to both be kept\n// while `Cards` is immutable singleton of all available cads, StackCards is not and\n// using a non-string key, we'll wind up with missing references not hitting the cache.\n\nexport const getKey = ({ card: { suit, value }, selected }: StackCard) =>\n  `${suit}_${value}_${(selected || false).toString()}`\n\nexport const cardCache: Map<string, ImageData> = new Map()\n\nlet c2: HTMLCanvasElement\n\nexport const initialize = (context: DrawingContext) => {\n  const { width, height } = getCardDimensions(context)\n  cardCache.set('hidden', getHiddenImageData(context))\n  cardCache.set('empty', getEmptyImageData(context))\n  cardCache.set('error', getErrorImageData(context))\n  Cards.forEach((card) => {\n    cardCache\n      .set(getKey({ card, selected: true }), getCardImageData(context, { card, selected: true }))\n      .set(getKey({ card, selected: false }), getCardImageData(context, { card, selected: false }))\n  })\n\n  c2 = document.createElement('canvas')\n  c2.width = width\n  c2.height = height\n  context.ctx.clearRect(0, 0, width + 2, height + 2)\n}\n\n// to get transarency working, (maybe other composition?) need an intermediary canvas to proxy the drawing.\n\nexport const writeDataToCanvas = (context: DrawingContext, data: ImageData, x: number, y: number) => {\n  const ctx2 = c2.getContext('2d')\n  ctx2?.putImageData(data, 0, 0)\n  context.ctx.drawImage(c2, x, y)\n}\n","const allFontSizes = Array.from<number, number>({ length: 200 }, (v, k) => k)\n\ninterface isBigEnough {\n  (width: number, height: number): boolean\n}\n\nexport const measureWidth = (ctx: CanvasRenderingContext2D, font: string, text: string) => {\n  ctx.font = font\n  return ctx.measureText(text).width\n}\n\nexport const measureHeight = (ctx: CanvasRenderingContext2D, font: string) => {\n  ctx.font = font\n  return ctx.measureText('M').width // close enough\n}\n\nconst searchFontSize = (\n  ctx: CanvasRenderingContext2D,\n  isBigEnough: isBigEnough,\n  text: string,\n  min: number,\n  max: number,\n): string => {\n  const index = Math.floor((max + min) / 2)\n  const font = `${allFontSizes[index]}px sans-serif`\n  const width = measureWidth(ctx, font, text)\n  const height = measureHeight(ctx, font)\n  if (min > max) return font\n  if (isBigEnough(width, height)) return searchFontSize(ctx, isBigEnough, text, min, index - 1)\n  return searchFontSize(ctx, isBigEnough, text, index + 1, max)\n}\n\nexport const search = (ctx: CanvasRenderingContext2D, isBigEnough: isBigEnough, text: string) =>\n  searchFontSize(ctx, isBigEnough, text, 0, allFontSizes.length - 1)\n","import * as React from 'react'\nimport { GameCtx } from '../components/GameCanvas'\nimport { Clickable, DrawingContext, Drawable } from '../drawing/Common'\n\nexport interface Drawer {\n  (context: DrawingContext): Drawable | null\n}\n\nexport const useDrawing = (draw: Drawer, events: Clickable = {}) => {\n  const gameContext = React.useContext(GameCtx)\n  const performCleanup = React.useRef(true)\n  const lastWidth = React.useRef(gameContext?.context.width ?? 0)\n  const lastHeight = React.useRef(gameContext?.context.height ?? 0)\n\n  // should only clear the rects if we haven't just resized the screen\n  // a screen resize will already clear the entire canvas\n  // if this isn't tracked, we end up drawing a new game and clear out the old sizes, leaving blank holes.\n\n  React.useEffect(() => {\n    if (!gameContext) return\n    performCleanup.current = !(\n      (lastHeight.current !== gameContext.context.height || lastWidth.current !== gameContext.context.width) &&\n      lastHeight.current > 0 &&\n      lastWidth.current > 0\n    )\n  }, [gameContext])\n\n  React.useEffect(() => {\n    if (gameContext == null) return\n    const { add, remove, context } = gameContext\n    const { ctx } = context\n\n    const thing = draw(context)\n    if (thing == null) return\n    add(thing, events)\n\n    return () => {\n      remove(thing.path)\n      if (performCleanup.current) {\n        ctx.clearRect(thing.box.x, thing.box.y, thing.box.width, thing.box.height)\n      }\n      performCleanup.current = true\n    }\n  })\n}\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport * as offline from 'offline-plugin/runtime'\n\nimport App from './components/App'\n\nconst NODE_ENV = process.env.NODE_ENV\nif (NODE_ENV === 'production') {\n  offline.install({\n    onUpdateReady() {\n      offline.applyUpdate()\n    },\n    onUpdated() {\n      window.location.reload()\n    },\n  })\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n","import * as React from 'react'\n\nimport { Provider } from 'react-redux'\n\nimport configStore from '../store'\nimport { ThunkDispatch, initialize } from '../redux/thunks'\nimport Container from './Container'\n\nconst App: React.FC = () => {\n  const store = configStore()\n  const dispatch = store.dispatch as ThunkDispatch\n\n  dispatch(initialize())\n\n  return (\n    <Provider store={store}>\n      <Container />\n    </Provider>\n  )\n}\n\nexport { App }\n\nexport default React.memo(App)\n","import { createStore, applyMiddleware } from 'redux'\nimport thunk, { ThunkMiddleware } from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport reducer, { StoreState, StoreActions } from './redux'\nimport subscribe from 'redux-subscribe-reselect'\nimport { saveScore, GameStateStore } from './redux/game-state'\nimport { getGameState } from './redux/selectors'\n\nexport default () => {\n  const middleware = []\n\n  middleware.push(thunk as ThunkMiddleware<StoreState, StoreActions>)\n\n  if (process.env.NODE_ENV !== 'production') {\n    middleware.push(\n      createLogger({\n        stateTransformer: (state: StoreState) => ({\n          gameState: state.gameState.present,\n          stacks: state.stacks.present,\n        }),\n      }),\n    )\n  }\n\n  const store = createStore(reducer, void 0, applyMiddleware(...middleware))\n  subscribe(store, getGameState, (score: GameStateStore) => saveScore(score))\n  return store\n}\n","import { combineReducers } from 'redux'\nimport stacks, { CardActions, StackStore } from './stacks'\nimport gameState, { GameStateActions, GameStateStore } from './game-state'\nimport { History, UndoableActions } from './undoable'\n\nexport type StoreActions = GameStateActions | CardActions | UndoableActions\n\nexport type StoreState = {\n  stacks: History<StackStore>\n  gameState: History<GameStateStore>\n}\n\nexport default combineReducers<StoreState, StoreActions>({ stacks, gameState })\n","import * as React from 'react'\nimport { hot } from 'react-hot-loader/root'\nimport { useDispatch, useSelector } from 'react-redux'\nimport FireworksComponent from './Fireworks'\nimport { undo, redo } from '../redux/undoable'\nimport GameCanvas from './GameCanvas'\nimport StackElement from './StackElement'\n\nimport { getDraws, getShowing, getStacks } from '../redux/selectors'\nimport TopBar from './TopBar'\nimport { performMoves } from '../redux/thunks'\n\nconst Container: React.FC = () => {\n  const dispatch = useDispatch()\n  const stacks = useSelector(getStacks)\n  const draws = useSelector(getDraws)\n  const showing = useSelector(getShowing)\n\n  React.useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.keyCode !== 90) return\n      if (e.ctrlKey && e.shiftKey) {\n        dispatch(redo())\n      } else if (e.ctrlKey) {\n        dispatch(undo())\n      }\n    }\n    document.addEventListener('keydown', handler)\n    return () => document.removeEventListener('keydown', handler)\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const handler = (e: MouseEvent) => {\n      if (e.button === 1) {\n        e.preventDefault()\n        dispatch(performMoves())\n      }\n    }\n    document.addEventListener('mousedown', handler)\n    return () => document.removeEventListener('mousedown', handler)\n  }, [dispatch])\n\n  return (\n    <div>\n      <FireworksComponent />\n      <GameCanvas>\n        <TopBar />\n        {stacks.map((stack) => (\n          <StackElement key={`${stack.type}-${stack.index}`} stack={stack} showing={showing} draws={draws} />\n        ))}\n      </GameCanvas>\n    </div>\n  )\n}\n\nexport default hot(React.memo(Container))\n","import * as React from 'react'\nimport { useSelector } from 'react-redux'\nimport * as FireworksCanvas from 'fireworks-canvas'\nimport { getGameWon } from '../redux/selectors'\n\nconst Fireworks: React.FC = () => {\n  const ref = React.useRef<HTMLDivElement>(null)\n  const fireworksObj = React.useRef<FireworksCanvas>()\n  const active = useSelector(getGameWon)\n  const display = active ? '' : 'none'\n\n  React.useEffect(() => {\n    if (ref.current == null) return\n    fireworksObj.current = new FireworksCanvas(ref.current)\n\n    const handleDocumentKeyDown = (ev: KeyboardEvent) => {\n      if (ev.keyCode === 27) fireworksObj.current?.stop()\n    }\n\n    document.addEventListener('keydown', handleDocumentKeyDown)\n\n    return () => {\n      fireworksObj.current?.destroy()\n    }\n  }, [ref, active])\n\n  React.useEffect(() => {\n    if (active) {\n      fireworksObj.current?.stop()\n    } else {\n      fireworksObj.current?.start()\n    }\n  }, [active])\n\n  return (\n    <div\n      style={{\n        display,\n        top: '0',\n        left: '0',\n        width: '100vw',\n        height: '100vh',\n        position: 'absolute',\n      }}\n      ref={ref}\n    />\n  )\n}\n\nexport default React.memo(Fireworks)\n","export enum ColorSchemeType {\n  dark,\n  light,\n}\n\nexport type ColorScheme = {\n  background: string\n  faceDown: string\n  buttonBorder: string\n  cardBorder: string\n  faceUp: string\n  selected: string\n  red: string\n  black: string\n  emptyColor: string\n  errorColor: string\n}\n\nexport const colorSchemes: { [key in ColorSchemeType]: ColorScheme } = {\n  [ColorSchemeType.dark]: {\n    background: '#000',\n    emptyColor: '#060606',\n    faceUp: '#222',\n    faceDown: '#333',\n    buttonBorder: '#ddd',\n    cardBorder: '#000',\n    black: '#999',\n    red: '#900',\n    selected: '#660',\n    errorColor: '#900',\n  },\n  [ColorSchemeType.light]: {\n    background: '#fff',\n    emptyColor: '#eee',\n    faceUp: '#ddd',\n    faceDown: '#ccc',\n    buttonBorder: '#000',\n    cardBorder: '#333',\n    black: '#333',\n    red: 'crimson',\n    selected: 'yellow',\n    errorColor: 'red',\n  },\n}\n","import { ValueType, SuitType, StackCard } from '../lib/Card'\nimport { Box, DrawingContext } from './Common'\nimport { isBig, isRed } from '../lib/util'\nimport { search, measureHeight } from './FontSize'\n\nimport { getCardDimensions, getVerticalMarginSize, getHorizontalMarginSize } from './Layout'\n\ntype Glyph = {\n  glyph: ValueType | SuitType\n  x: number\n  y: number\n  rotated: boolean\n  textAlign: CanvasTextAlign\n  textBaseline: CanvasTextBaseline\n  font: string\n}\n\ninterface GetCard {\n  (context: DrawingContext, card?: StackCard): ImageData\n}\n\nexport const getBoxPath = ({ x, y, width, height }: Box, radius = 10, smaller = 0) => {\n  const path = new Path2D()\n\n  const dx = x + smaller\n  const dy = y + smaller\n  const dw = width - smaller * 2\n  const dh = height - smaller * 2\n\n  path.moveTo(dx + radius, dy)\n  path.lineTo(dx + dw - radius, dy)\n  path.quadraticCurveTo(dx + dw, dy, dx + dw, dy + radius)\n  path.lineTo(dx + dw, dy + dh - radius)\n  path.quadraticCurveTo(dx + dw, dy + dh, dx + dw - radius, dy + dh)\n  path.lineTo(dx + radius, dy + dh)\n  path.quadraticCurveTo(dx, dy + dh, dx, dy + dh - radius)\n  path.lineTo(dx, dy + radius)\n  path.quadraticCurveTo(dx, dy, dx + radius, dy)\n  path.closePath()\n  return path\n}\n\nenum FontSizeType {\n  Regular,\n  Corner,\n}\n\nexport const getGlyphLocations = (context: DrawingContext, { card, hidden }: StackCard): Glyph[] => {\n  if (hidden) return []\n\n  const { ctx } = context\n  const { width: cardWidth, height: cardHeight } = getCardDimensions(context)\n  const gutterHeight = getVerticalMarginSize(context)\n  const gutterWidth = getHorizontalMarginSize(context)\n\n  const cornerWidth = Math.floor(cardWidth * 0.2)\n  const figureOutFontSize = (type: FontSizeType) =>\n    search(\n      ctx,\n      (width: number, height: number) =>\n        type === FontSizeType.Corner\n          ? width > cornerWidth\n          : isBig(card)\n          ? width > cardWidth - Math.floor(cardWidth / 5) * 2\n          : width > Math.floor(cardWidth / 5) && height > Math.floor(cardHeight / 20),\n      type === FontSizeType.Corner ? '10' : '\\u2665',\n    )\n\n  const fontSizes: { [key in FontSizeType]: string } = {\n    [FontSizeType.Corner]: figureOutFontSize(FontSizeType.Corner),\n    [FontSizeType.Regular]: figureOutFontSize(FontSizeType.Regular),\n  }\n\n  // 20% of width is reserved for corner pieces\n  // y of suit is margin + height of value + margin\n  const cornerHeight = measureHeight(ctx, fontSizes[FontSizeType.Corner])\n\n  const cornerValueX = gutterWidth / 2\n  const cornerValueY = gutterHeight / 2\n  const cornerSuitX = gutterWidth / 2\n  const cornerSuitY = gutterWidth / 2 + cornerHeight\n\n  const { suit, value } = card\n\n  // top-left, bottom-right glyphs\n  const positions = [\n    { x: cornerValueX, y: cornerValueY, glyph: value },\n    { x: cornerSuitX, y: cornerSuitY, glyph: suit },\n  ].reduce((memo, glyph) => {\n    memo.push(\n      {\n        ...glyph,\n        rotated: false,\n        textAlign: 'left',\n        textBaseline: 'top',\n        font: fontSizes[FontSizeType.Corner],\n      },\n      {\n        ...glyph,\n        rotated: true,\n        textAlign: 'left',\n        textBaseline: 'top',\n        font: fontSizes[FontSizeType.Corner],\n      },\n    )\n    return memo\n  }, [] as Glyph[])\n\n  type ypos = 0 | 1 | 2 | 3 | 4 | 5 | 6\n\n  type xpos = 0 | 1 | 2\n\n  const pos: { x: xpos; y: ypos }[] = []\n\n  if (\n    [\n      ValueType.ace,\n      ValueType.three,\n      ValueType.five,\n      ValueType.nine,\n      ValueType.jack,\n      ValueType.queen,\n      ValueType.king,\n    ].includes(value)\n  ) {\n    pos.push({ x: 1, y: 3 })\n  }\n\n  if ([ValueType.two, ValueType.three].includes(value)) {\n    pos.push({ x: 1, y: 0 }, { x: 1, y: 6 })\n  }\n\n  if (\n    [\n      ValueType.four,\n      ValueType.five,\n      ValueType.six,\n      ValueType.seven,\n      ValueType.eight,\n      ValueType.nine,\n      ValueType.ten,\n    ].includes(value)\n  ) {\n    pos.push({ x: 0, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 6 }, { x: 2, y: 6 })\n  }\n\n  if ([ValueType.six, ValueType.seven, ValueType.eight].includes(value)) {\n    pos.push({ x: 0, y: 3 }, { x: 2, y: 3 })\n  }\n\n  if ([ValueType.seven, ValueType.ten, ValueType.eight].includes(value)) {\n    pos.push({ x: 1, y: 1 })\n  }\n\n  if ([ValueType.nine, ValueType.ten].includes(value)) {\n    pos.push({ x: 0, y: 2 }, { x: 2, y: 2 }, { x: 0, y: 4 }, { x: 2, y: 4 })\n  }\n\n  if ([ValueType.ten, ValueType.eight].includes(value)) {\n    pos.push({ x: 1, y: 5 })\n  }\n\n  const getTop = (y: ypos) => {\n    switch (y) {\n      case 0:\n      case 6:\n        return cardHeight * 0.2\n      case 1:\n      case 5:\n        return cardHeight * 0.3\n      case 2:\n      case 4:\n        return cardHeight * 0.4\n      case 3:\n        return cardHeight * 0.5\n    }\n  }\n\n  const getLeft = (x: xpos) => {\n    switch (x) {\n      case 0:\n        return cardWidth * 0.25\n      case 1:\n        return cardWidth * 0.5\n      case 2:\n        return cardWidth * 0.75\n    }\n  }\n\n  const getTextAlign = (x: xpos): CanvasTextAlign => {\n    switch (x) {\n      case 0:\n        return 'left'\n      case 1:\n        return 'center'\n      case 2:\n        return 'right'\n    }\n  }\n\n  pos.forEach(({ x, y }) => {\n    positions.push({\n      x: getLeft(x),\n      y: getTop(y),\n      glyph: suit,\n      textAlign: getTextAlign(x),\n      textBaseline: 'middle',\n      rotated: y > 3,\n      font: fontSizes[FontSizeType.Regular],\n    })\n  })\n\n  return positions\n}\n\nexport const getEmptyImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(0, 0, width, height)\n  ctx.fillStyle = colorScheme.emptyColor\n  ctx.fillRect(box.x, box.y, box.width, box.height)\n  ctx.lineWidth = 0.5\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.strokeRect(box.x, box.y, box.width, box.height)\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getHiddenImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.lineWidth = 2\n  ctx.stroke(getBoxPath(box, 10))\n  ctx.fillStyle = colorScheme.faceDown\n  ctx.fill(getBoxPath(box, 10, 0.5))\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getCardImageData: GetCard = (context: DrawingContext, card: StackCard) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.lineWidth = 2\n  ctx.stroke(getBoxPath(box, 10))\n\n  ctx.fillStyle = card.selected ? colorScheme.selected : colorScheme.faceUp\n  ctx.fill(getBoxPath(box, 10, 0.5))\n\n  for (const glyph of getGlyphLocations(context, card)) {\n    ctx.fillStyle = isRed(card.card) ? colorScheme.red : colorScheme.black\n    ctx.textAlign = glyph.textAlign\n    ctx.textBaseline = glyph.textBaseline\n    ctx.font = glyph.font\n    if (glyph.rotated) {\n      ctx.save()\n      ctx.translate(width, height)\n      ctx.rotate(Math.PI)\n    }\n    ctx.fillText(glyph.glyph, glyph.x + box.x * (glyph.rotated ? -1 : 1), glyph.y + box.y * (glyph.rotated ? -1 : 1))\n    if (glyph.rotated) ctx.restore()\n  }\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getErrorImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.fillStyle = colorScheme.emptyColor\n  ctx.fill(getBoxPath(box))\n  ctx.font = '48px sans-serif'\n  ctx.textAlign = 'center'\n  ctx.textBaseline = 'middle'\n  ctx.fillStyle = colorScheme.errorColor\n  ctx.fillText('X', box.width / 2, box.height / 2)\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n","import * as React from 'react'\nimport { Dimensions } from '../drawing/Common'\n\ntype CanvasSizeReturn = {\n  ctx?: CanvasRenderingContext2D\n  width?: number\n  height?: number\n  handleCanvasRef: (canvas: HTMLCanvasElement) => void\n}\n\nexport const useCanvasSize = (): CanvasSizeReturn => {\n  const [canvas, setCanvas] = React.useState<HTMLCanvasElement | null>(null)\n  const handleCanvasRef = React.useCallback((canvas: HTMLCanvasElement) => canvas && setCanvas(canvas), [])\n\n  const getSize = () => ({ width: window.innerWidth, height: window.innerHeight })\n\n  const [size, setSize] = React.useState<Dimensions>()\n\n  React.useEffect(() => {\n    if (!canvas) return\n    const ctx = canvas.getContext('2d')\n    if (ctx == null) return\n    let tid: number\n    const handleSize = () => {\n      if (tid) clearTimeout(tid)\n      tid = window.setTimeout(() => setSize(getSize()), 300)\n    }\n    window.addEventListener('resize', handleSize)\n    return () => {\n      window.removeEventListener('resize', handleSize)\n    }\n  })\n\n  const retVal = React.useMemo(\n    () => ({\n      handleCanvasRef,\n      ...(canvas && {\n        ctx: canvas.getContext('2d') as CanvasRenderingContext2D,\n        ...(size ?? getSize()),\n      }),\n    }),\n    [size, handleCanvasRef, canvas],\n  )\n\n  return retVal\n}\n","import * as React from 'react'\nimport { GameCtx } from './GameCanvas'\nimport { drawStack, StackDrawingContext, getStackDrawingContext } from '../drawing/Stack'\nimport { Stack, StackDirection, StackType } from '../lib/Card'\nimport { useDispatch } from 'react-redux'\nimport { clickCard, doubleClickCard } from '../redux/thunks'\nimport { Point, Drawable } from '../drawing/Common'\nimport { useDrawing } from '../hooks/useDrawing'\nimport { useMemo } from 'react'\n\nconst StackElement: React.FC<{\n  stack: Stack\n  draws: number\n  showing: number\n}> = ({ stack, draws, showing }) => {\n  const dispatch = useDispatch()\n  const gameContext = React.useContext(GameCtx)\n\n  const drawingOpts = useMemo<StackDrawingContext | null>(\n    () => gameContext && getStackDrawingContext(gameContext.context, stack, { draws, showing }),\n    [gameContext, stack, draws, showing],\n  )\n\n  const onDoubleClick = React.useCallback(\n    (thing: Drawable, point: Point) => {\n      if (gameContext == null || drawingOpts == null) return\n      const prop = stack.direction === StackDirection.horizontal ? 'x' : 'y'\n      const cards = stack.cards.slice(-drawingOpts.max)\n      const index = Math.min(cards.length - 1, Math.floor((point[prop] - drawingOpts.box[prop]) / drawingOpts.space))\n      if (stack.type !== StackType.waste || index === cards.length - 1)\n        dispatch(doubleClickCard({ stack, stackCard: cards[index] }))\n    },\n    [dispatch, gameContext, drawingOpts, stack],\n  )\n\n  const onClick = React.useCallback(\n    (thing: Drawable, point: Point) => {\n      if (gameContext == null || drawingOpts == null) return\n      const prop = stack.direction === StackDirection.horizontal ? 'x' : 'y'\n      const cards = stack.cards.slice(-drawingOpts.max)\n      const index = Math.min(cards.length - 1, Math.floor((point[prop] - drawingOpts.box[prop]) / drawingOpts.space))\n      if (stack.type !== StackType.waste || index === cards.length - 1)\n        dispatch(clickCard({ stack, stackCard: cards[index] }))\n    },\n    [dispatch, gameContext, drawingOpts, stack],\n  )\n\n  useDrawing((context) => drawStack(context, drawingOpts), { onClick, onDoubleClick })\n\n  return null\n}\n\nexport { StackElement }\nexport default React.memo(StackElement)\n","import { Stack, StackDirection, StackType } from '../lib/Card'\nimport { writeDataToCanvas, cardCache, getKey, DrawingContext, DrawRoutine, Box } from './Common'\nimport { getStackCardOffsetWidth, getStackCardOffsetHeight, getStackBox } from './Layout'\n\nexport type StackDrawingOptions = {\n  draws: number\n  showing: number\n}\n\nexport type StackDrawingContext = StackDrawingOptions & {\n  stack: Stack\n  space: number\n  max: number\n  box: Box\n}\n\nexport const getStackDrawingContext = (\n  context: DrawingContext,\n  stack: Stack,\n  opts: StackDrawingOptions,\n): StackDrawingContext => {\n  const max =\n    stack.type === StackType.stock || stack.type === StackType.foundation\n      ? 1\n      : stack.type === StackType.waste\n      ? opts.showing || 0\n      : stack.cards.length\n\n  const box = getStackBox(context, stack, max)\n\n  const space =\n    stack.direction === StackDirection.horizontal ? getStackCardOffsetWidth(context) : getStackCardOffsetHeight(context)\n\n  return {\n    stack,\n    draws: opts.draws,\n    showing: opts.showing,\n    space,\n    box,\n    max,\n  }\n}\n\nexport const drawStack: DrawRoutine<StackDrawingContext> = (context, drawingOpts) => {\n  if (drawingOpts == null) return null\n  const { stack, draws, max, space, box } = drawingOpts\n  const cards = stack.cards.slice(-max)\n\n  const path = new Path2D()\n  path.rect(box.x, box.y, box.width, box.height)\n  path.closePath()\n\n  const empty = cards.length === 0\n  const error = stack.type === StackType.stock && empty && draws === 0\n  const elements = []\n\n  if (error) elements.push({ data: cardCache.get('error'), x: box.x, y: box.y })\n  else if (empty) elements.push({ data: cardCache.get('empty'), x: box.x, y: box.y })\n  else\n    cards.forEach((card, i) => {\n      const drawing = card.hidden ? cardCache.get('hidden') : cardCache.get(getKey(card))\n      if (drawing) {\n        const x = stack.direction === StackDirection.horizontal ? i * space : 0\n        const y = stack.direction === StackDirection.horizontal ? 0 : i * space\n        elements.push({ data: drawing, x: box.x + x, y: box.y + y })\n      }\n    })\n\n  for (const { data, x, y } of elements) data && writeDataToCanvas(context, data, x, y)\n  return { path, box }\n}\n","import * as React from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { getScoringType, getScore } from '../redux/selectors'\nimport { ScoringType } from '../redux/game-state'\nimport { initialize } from '../redux/thunks'\nimport { useDrawing } from '../hooks/useDrawing'\nimport { drawLabel, getLabelDrawingContext } from '../drawing/Label'\nimport { GameCtx } from './GameCanvas'\nimport { getHorizontalMarginSize, getVerticalMarginSize } from '../drawing/Layout'\n\nconst TopBar: React.FC = () => {\n  const dispatch = useDispatch()\n  const gameContext = React.useContext(GameCtx)\n  const scoringType = useSelector(getScoringType)\n  const currentScore = useSelector(getScore)\n\n  const otherGameType = React.useMemo(\n    () => (scoringType === ScoringType.vegas ? ScoringType.regular : ScoringType.vegas),\n    [scoringType],\n  )\n\n  const deets = React.useMemo(() => {\n    if (gameContext == null) return null\n\n    const newGame = getLabelDrawingContext(gameContext.context, {\n      x: 5,\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: 'New Game',\n      border: true,\n    })\n\n    const switchGame = getLabelDrawingContext(gameContext.context, {\n      x: newGame.box.x + newGame.box.width + getHorizontalMarginSize(gameContext.context),\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: `Switch to ${ScoringType[otherGameType]}`,\n      border: true,\n    })\n\n    const score = getLabelDrawingContext(gameContext.context, {\n      x: 0,\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: `Score: ${currentScore}`,\n      border: false,\n    })\n\n    const version = getLabelDrawingContext(gameContext.context, {\n      x: 0,\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: process.env.version || '',\n      border: false,\n    })\n\n    // position the x of the switch game type button to the right of the new game button\n    switchGame.box.x = newGame.box.x + newGame.box.width + getHorizontalMarginSize(gameContext.context)\n\n    // position the x of the score to the very right of the board\n    score.box.x = gameContext.context.width - score.box.width - getHorizontalMarginSize(gameContext.context)\n\n    // version goes in the bottom right\n    version.box.x = gameContext.context.width - version.box.width - getHorizontalMarginSize(gameContext.context)\n    version.box.y = gameContext.context.height - version.box.height - getVerticalMarginSize(gameContext.context)\n\n    return { newGame, switchGame, score, version }\n  }, [gameContext, currentScore, otherGameType])\n\n  const handleNewGame = React.useCallback(() => dispatch(initialize()), [dispatch])\n\n  const handleSwitchGame = React.useCallback(() => dispatch(initialize(otherGameType)), [dispatch, otherGameType])\n\n  useDrawing((context) => deets && drawLabel(context, deets.newGame), { onClick: handleNewGame })\n\n  useDrawing((context) => deets && drawLabel(context, deets.switchGame), { onClick: handleSwitchGame })\n\n  useDrawing((context) => deets && drawLabel(context, deets.score))\n\n  useDrawing((context) => deets && drawLabel(context, deets.version))\n\n  return null\n}\n\nexport { TopBar }\nexport default React.memo(TopBar)\n","import { DrawRoutine, DrawingContext, Box } from './Common'\n\nimport { search, measureWidth } from './FontSize'\n\ntype LabelDrawingOpts = {\n  label: string\n  padding: number\n  x?: number\n  y: number\n  height: number\n  border?: boolean\n}\n\ntype LabelDrawingContext = LabelDrawingOpts & {\n  box: Box\n  font: string\n}\n\nexport const getLabelDrawingContext = (context: DrawingContext, opts: LabelDrawingOpts): LabelDrawingContext => {\n  const isBigEnough = (_: number, boxHeight: number) => boxHeight > height\n  const { ctx } = context\n  const { x, y, height, label } = opts\n  const font = search(context.ctx, isBigEnough, label)\n  const width = measureWidth(ctx, font, label)\n  return {\n    ...opts,\n    box: { x: x ?? 0, y, width: width + opts.padding * 2, height: height + opts.padding * 2 },\n    font,\n  }\n}\n\nexport const drawLabel: DrawRoutine<LabelDrawingContext> = (context, drawingOpts) => {\n  if (drawingOpts == null) return null\n  const { ctx } = context\n  const { font, box, label, padding, border } = drawingOpts\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(box.x, box.y, box.width, box.height)\n  ctx.closePath()\n  ctx.clip()\n\n  ctx.font = font\n  ctx.textAlign = 'left'\n  ctx.textBaseline = 'top'\n  ctx.fillText(label, box.x + padding, box.y + padding)\n\n  if (border) {\n    ctx.strokeStyle = context.colorScheme.buttonBorder\n    ctx.strokeRect(box.x, box.y, box.width, box.height)\n  }\n\n  ctx.restore()\n\n  const path = new Path2D()\n  path.rect(box.x, box.y, box.width, box.height)\n  path.closePath()\n\n  return { box, path }\n}\n"],"sourceRoot":""}