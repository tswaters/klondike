{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ts/lib/Card.ts","webpack:///./src/ts/redux/selectors.ts","webpack:///./src/ts/lib/util.ts","webpack:///./src/ts/redux/undoable.ts","webpack:///./src/ts/redux/game-state.ts","webpack:///./src/ts/components/GameCanvas.tsx","webpack:///./src/ts/drawing/Layout.ts","webpack:///./src/ts/redux/stacks.ts","webpack:///./src/ts/redux/init.ts","webpack:///./src/ts/redux/thunks.ts","webpack:///./src/ts/drawing/Common.ts","webpack:///./src/ts/drawing/FontSize.ts","webpack:///./src/ts/hooks/useDrawing.ts","webpack:///./src/ts/index.tsx","webpack:///./src/ts/components/App.tsx","webpack:///./src/ts/store.ts","webpack:///./src/ts/redux/index.ts","webpack:///./src/ts/components/Container.tsx","webpack:///./src/ts/components/Fireworks.tsx","webpack:///./src/ts/drawing/ColorScheme.ts","webpack:///./src/ts/drawing/Card.ts","webpack:///./src/ts/hooks/useCanvasSize.ts","webpack:///./src/ts/components/StackElement.tsx","webpack:///./src/ts/drawing/Stack.ts","webpack:///./src/ts/components/TopBar.tsx","webpack:///./src/ts/drawing/Label.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","ValueType","SuitType","StackDirection","StackType","Cards","values","suit","freeze","getAllStacks","createSelector","state","stacks","present","getFoundation","filter","stack","type","foundation","getGameWon","every","cards","getStock","stock","getWaste","waste","getFoundationStack","_","card","find","last","getTopCard","ace","isSequential","getGameState","gameState","score","getScore","getScoringType","scoringType","getDraws","draws","getShowing","showing","getSelection","selection","disallowClickStock","rnd","Math","imul","min","max","floor","sumConsecutive","random","sameStack","stack1","stack2","index","sameCard","stackCard1","stackCard2","stackContainsCard","stackCards","stackCard","some","item","card1","valueToInt","isRed","diamond","heart","includes","isBlack","club","spade","isBig","jack","queen","king","isValidMove","destination","parseInt","destroy","UNDO","undo","REDO","redo","checkpoint","undoable","reducer","initialState","past","undefined","future","action","previous","next","newFuture","newPresent","ScoringType","ScoreType","getSavedScore","localStorage","getItem","parsed","Number","isNaN","err","saveScore","vegas","setItem","toString","getScoreChange","scoreType","regular","tableauToFoundation","wasteToFoundation","revealCard","wasteToTableau","foundationToTableau","incrementScore","decrementDraws","Infinity","INITIALIZE","MOVE_CARDS","to","from","GameCtx","React","createContext","intersect","evt","pointsRef","nativeEvent","e","canvas","target","point","x","offsetX","y","offsetY","ctx","getContext","path","keys","isPointInPath","thing","GameCanvas","children","useRef","Map","clickHandlers","doubleClickHandlers","colorScheme","useState","colorSchemes","ColorSchemeType","dark","width","height","handleCanvasRef","useCanvasSize","context","useMemo","useLayoutEffect","initialize","events","current","set","onClick","onDoubleClick","delete","handleCanvasDoubleClick","useCallback","event","handleCanvasClick","id","style","backgroundColor","background","top","left","position","ref","innerWidth","innerHeight","Provider","memo","getStackCardOffsetWidth","getStackCardOffsetHeight","getVerticalMarginSize","getHorizontalMarginSize","getTopbarBox","getCardDimensions","horizontalMargin","verticalMargin","topBarBox","stackCardOffsetHeight","usedVerticalSpace","usedHorizontalSpace","maxWidth","maxHeight","getStackBox","topBar","cardLength","usedWidth","baseX","stackWidth","direction","horizontal","stackHeight","vertical","tableau","SELECT","selectCard","DESELECT","deselectCard","REVEAL_TOP","reveal","throwStock","reverse","hidden","recycleWaste","moveCards","from_card","findIndex","reducers","map","a","selected","Array","newScoringType","dispatch","getState","availableCards","clickCard","clickedStack","clickedCard","doubleClickCard","c2","getKey","cardCache","getHiddenImageData","getEmptyImageData","getErrorImageData","forEach","getCardImageData","document","createElement","clearRect","writeDataToCanvas","ctx2","putImageData","drawImage","allFontSizes","v","k","measureWidth","font","text","measureText","measureHeight","searchFontSize","isBigEnough","search","useDrawing","draw","gameContext","useContext","performCleanup","lastWidth","lastHeight","useEffect","add","remove","box","offline","install","applyUpdate","location","reload","ReactDOM","render","getElementById","App","store","middleware","createStore","applyMiddleware","combineReducers","hot","useDispatch","useSelector","handler","keyCode","ctrlKey","shiftKey","addEventListener","removeEventListener","fireworksObj","active","display","FireworksCanvas","ev","stop","start","emptyColor","faceUp","faceDown","buttonBorder","cardBorder","black","red","errorColor","light","FontSizeType","getBoxPath","radius","smaller","Path2D","dx","dy","dw","dh","moveTo","lineTo","quadraticCurveTo","closePath","getGlyphLocations","cardWidth","cardHeight","gutterHeight","gutterWidth","cornerWidth","figureOutFontSize","Corner","fontSizes","Regular","cornerValueX","cornerValueY","cornerSuitX","cornerSuitY","positions","glyph","reduce","rotated","textAlign","textBaseline","pos","three","five","nine","two","four","six","seven","eight","ten","getTop","getLeft","getTextAlign","fillStyle","fillRect","lineWidth","strokeStyle","strokeRect","getImageData","stroke","fill","save","translate","rotate","PI","fillText","restore","setCanvas","getSize","size","setSize","tid","handleSize","clearTimeout","setTimeout","StackElement","drawingOpts","getStackDrawingContext","prop","space","drawStack","opts","rect","empty","error","elements","drawing","TopBar","currentScore","otherGameType","deets","newGame","getLabelDrawingContext","padding","label","border","switchGame","version","handleNewGame","handleSwitchGame","drawLabel","boxHeight","beginPath","clip"],"mappings":"aACE,SAASA,EAAqBC,GAQ7B,IAPA,IAMIC,EAAUC,EANVC,EAAWH,EAAK,GAChBI,EAAcJ,EAAK,GACnBK,EAAiBL,EAAK,GAIHM,EAAI,EAAGC,EAAW,GACpCD,EAAIH,EAASK,OAAQF,IACzBJ,EAAUC,EAASG,GAChBG,OAAOC,UAAUC,eAAeC,KAAKC,EAAiBX,IAAYW,EAAgBX,IACpFK,EAASO,KAAKD,EAAgBX,GAAS,IAExCW,EAAgBX,GAAW,EAE5B,IAAID,KAAYG,EACZK,OAAOC,UAAUC,eAAeC,KAAKR,EAAaH,KACpDc,EAAQd,GAAYG,EAAYH,IAKlC,IAFGe,GAAqBA,EAAoBhB,GAEtCO,EAASC,QACdD,EAASU,OAATV,GAOD,OAHAW,EAAgBJ,KAAKK,MAAMD,EAAiBb,GAAkB,IAGvDe,IAER,SAASA,IAER,IADA,IAAIC,EACIf,EAAI,EAAGA,EAAIY,EAAgBV,OAAQF,IAAK,CAG/C,IAFA,IAAIgB,EAAiBJ,EAAgBZ,GACjCiB,GAAY,EACRC,EAAI,EAAGA,EAAIF,EAAed,OAAQgB,IAAK,CAC9C,IAAIC,EAAQH,EAAeE,GACG,IAA3BX,EAAgBY,KAAcF,GAAY,GAE3CA,IACFL,EAAgBQ,OAAOpB,IAAK,GAC5Be,EAASM,EAAoBA,EAAoBC,EAAIN,EAAe,KAItE,OAAOD,EAIR,IAAIQ,EAAmB,GAKnBhB,EAAkB,CACrBiB,EAAG,GAGAZ,EAAkB,GAGtB,SAASS,EAAoB1B,GAG5B,GAAG4B,EAAiB5B,GACnB,OAAO4B,EAAiB5B,GAAU8B,QAGnC,IAAIC,EAASH,EAAiB5B,GAAY,CACzCK,EAAGL,EACHgC,GAAG,EACHF,QAAS,IAUV,OANAhB,EAAQd,GAAUW,KAAKoB,EAAOD,QAASC,EAAQA,EAAOD,QAASJ,GAG/DK,EAAOC,GAAI,EAGJD,EAAOD,QAKfJ,EAAoBO,EAAInB,EAGxBY,EAAoBQ,EAAIN,EAGxBF,EAAoBS,EAAI,SAASL,EAASM,EAAMC,GAC3CX,EAAoBY,EAAER,EAASM,IAClC5B,OAAO+B,eAAeT,EAASM,EAAM,CAAEI,YAAY,EAAMC,IAAKJ,KAKhEX,EAAoBgB,EAAI,SAASZ,GACX,oBAAXa,QAA0BA,OAAOC,aAC1CpC,OAAO+B,eAAeT,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DrC,OAAO+B,eAAeT,EAAS,aAAc,CAAEe,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKzC,OAAO0C,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBzC,OAAO+B,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBS,EAAEc,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAStB,GAChC,IAAIM,EAASN,GAAUA,EAAOiB,WAC7B,WAAwB,OAAOjB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAL,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASgB,EAAQC,GAAY,OAAO/C,OAAOC,UAAUC,eAAeC,KAAK2C,EAAQC,IAGzG7B,EAAoB8B,EAAI,GAExB,IAAIC,EAAaC,OAAqB,aAAIA,OAAqB,cAAK,GAChEC,EAAmBF,EAAW5C,KAAKuC,KAAKK,GAC5CA,EAAW5C,KAAOf,EAClB2D,EAAaA,EAAWG,QACxB,IAAI,IAAIvD,EAAI,EAAGA,EAAIoD,EAAWlD,OAAQF,IAAKP,EAAqB2D,EAAWpD,IAC3E,IAAIU,EAAsB4C,EAI1B1C,EAAgBJ,KAAK,CAAC,GAAG,IAElBM,I,gCCvJT,IAAY0C,EAgBAC,E,oHAhBZ,SAAYD,GACV,UACA,UACA,YACA,WACA,WACA,UACA,YACA,YACA,WACA,WACA,WACA,YACA,WAbF,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAgBrB,SAAYC,GACV,YACA,cACA,YACA,WAJF,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAkBpB,SAAYC,GACV,0BACA,sBAFF,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAe1B,SAAYC,GACV,oBACA,0BACA,gBACA,gBAJF,CAAY,EAAAA,YAAA,EAAAA,UAAS,KAerB,MAAMC,EAAgB,GAUb,EAAAA,QART,IAAK,MAAMpB,KAASrC,OAAO0D,OAAOL,GAChC,IAAK,MAAMM,KAAQ3D,OAAO0D,OAAOJ,GAC/BG,EAAMpD,KAAK,CAAEsD,OAAMtB,UAIvBrC,OAAO4D,OAAOH,I,mQCxEd,cAEA,OACA,OAIa,EAAAI,aAAe,EAAAC,eACzBC,GAAsBA,EAAMC,OAAOC,QAAQD,OAC3CA,GAAWA,GAGd,MAAME,EAAgB,EAAAJ,eAAe,EAAAD,aAAeG,GAClDA,EAAOG,OAAQC,GAAUA,EAAMC,OAAS,EAAAb,UAAUc,aAGvC,EAAAC,WAAa,EAAAT,eAAeI,EAAgBI,GACvDA,EAAWE,MAAOJ,GAAiC,KAAvBA,EAAMK,MAAM1E,SAG7B,EAAA2E,SAAW,EAAAZ,eACtB,EAAAD,aACCG,GAAWA,EAAOG,OAAQC,GAAUA,EAAMC,OAAS,EAAAb,UAAUmB,OAAO,IAG1D,EAAAC,SAAW,EAAAd,eACtB,EAAAD,aACCG,GAAWA,EAAOG,OAAQC,GAAUA,EAAMC,OAAS,EAAAb,UAAUqB,OAAO,IAG1D,EAAAC,mBAAqB,EAAAhB,eAChCI,EACA,CAACa,EAAYC,IAAeA,EAC5B,CAACV,EAAYU,IACXV,EAAWW,KAAK,EAAGR,YACjB,MAAMS,EAAO,EAAAC,WAAWV,GACxB,OAAe,MAARS,EAAeF,EAAK3C,QAAU,EAAAgB,UAAU+B,IAAMF,EAAKF,KAAKrB,OAASqB,EAAKrB,MAAQ,EAAA0B,aAAaL,EAAME,EAAKF,SAItG,EAAAM,aAAe,EAAAxB,eACzBC,GAAsBA,EAAMwB,UAAUtB,QACtCuB,GAAUA,GAGA,EAAAC,SAAW,EAAA3B,eAAe,EAAAwB,aAAeE,GAAUA,EAAMA,OAEzD,EAAAE,eAAiB,EAAA5B,eAAe,EAAAwB,aAAeE,GAAUA,EAAMG,aAE/D,EAAAC,SAAW,EAAA9B,eAAe,EAAAwB,aAAc,EAAGO,WAAYA,GAEvD,EAAAC,WAAa,EAAAhC,eAAe,EAAAwB,aAAc,EAAGS,aAAcA,GAE3D,EAAAC,aAAe,EAAAlC,eAAe,EAAAD,aAAeG,IACxD,MAAMI,EAAQJ,EAAOiB,KAAMb,GAA6B,MAAnBA,EAAM6B,WAC3C,OAAI7B,EAAc,CAAEY,KAAMZ,EAAM6B,UAAW7B,MAAOA,GAC3C,OAGI,EAAA8B,mBAAqB,EAAApC,eAChC,CAAC,EAAAY,SAAU,EAAAkB,UACX,CAACjB,EAAOkB,IAAiC,IAAvBlB,EAAMF,MAAM1E,QAA0B,IAAV8F,I,qOC7DhD,aAGa,EAAAM,IAAOhF,IAClB,MAAMgF,EAAM,KAAQ,WAAK,IAAK,GAAMhF,EAAIiF,KAAKC,KAAK,MAAOlF,KAAO,WAAK,IAErE,OADAgF,IACO,CAACG,EAAaC,IAAgBH,KAAKI,MAAML,KAASI,EAAMD,EAAM,IAAMA,GAGhE,EAAAG,eAAkB5G,GAAeA,GAAKA,EAAI,GAAM,EAEhD,EAAAsF,WAAcV,GAAyCA,EAAMA,EAAM1E,OAAS,GAE5E,EAAA2G,OAAS,CAACJ,EAAaC,IAAwBH,KAAKI,MAAMJ,KAAKM,SAAWH,GAAOD,EAOjF,EAAAK,UAAY,CAACC,EAAeC,IAAkBD,EAAOvC,OAASwC,EAAOxC,MAAQuC,EAAOE,QAAUD,EAAOC,MAErG,EAAAC,SAAW,CAACC,EAAuBC,IAC9CD,EAAWhC,KAAK3C,QAAU4E,EAAWjC,KAAK3C,OAAS2E,EAAWhC,KAAKrB,OAASsD,EAAWjC,KAAKrB,KAEjF,EAAAuD,kBAAoB,CAACC,EAAyBC,IACzDD,EAAWE,KAAMC,GAAoB,EAAAP,SAASO,EAAMF,IAEzC,EAAA/B,aAAe,CAACL,EAAYuC,IAAgBC,EAAWD,EAAMlF,OAAS,IAAMmF,EAAWxC,EAAK3C,OAE5F,EAAAoF,MAASzC,GAAe,CAAC,EAAA1B,SAASoE,QAAS,EAAApE,SAASqE,OAAOC,SAAS5C,EAAKrB,MAEzE,EAAAkE,QAAW7C,GAAe,CAAC,EAAA1B,SAASwE,KAAM,EAAAxE,SAASyE,OAAOH,SAAS5C,EAAKrB,MAExE,EAAAqE,MAAShD,GACpB,CAAC,EAAA3B,UAAU+B,IAAK,EAAA/B,UAAU4E,KAAM,EAAA5E,UAAU6E,MAAO,EAAA7E,UAAU8E,MAAMP,SAAS5C,EAAK3C,OAEpE,EAAA+F,YAAc,CAACpD,EAAYqD,IAChB,MAAfA,EACHrD,EAAK3C,QAAU,EAAAgB,UAAU8E,KACzB,EAAA9C,aAAagD,EAAYrD,KAAMA,KAC3B,EAAAyC,MAAMzC,IAAS,EAAA6C,QAAQQ,EAAYrD,OAAW,EAAA6C,QAAQ7C,IAAS,EAAAyC,MAAMY,EAAYrD,OAG3F,MAAMwC,EAAcnF,GACdA,IAAU,EAAAgB,UAAU+B,IAAY,EAChC/C,IAAU,EAAAgB,UAAU4E,KAAa,GACjC5F,IAAU,EAAAgB,UAAU6E,MAAc,GAClC7F,IAAU,EAAAgB,UAAU8E,KAAa,GAC9BG,SAASjG,EAAO,K,qICvCZ,EAAAkG,QAAU,KAAqB,CAAGlE,KAF/B,uBAIhB,MAAMmE,EAAO,kBAEA,EAAAC,KAAO,KAAkB,CAAGpE,KAAMmE,IAE/C,MAAME,EAAO,kBAEA,EAAAC,KAAO,KAAkB,CAAGtE,KAAMqE,IAIlC,EAAAE,WAAa,KAAwB,CAAGvE,KAFlC,0BAMN,EAAAwE,SAAsDC,IACjE,MAAMC,EAA2B,CAC/BC,KAAM,GACN/E,QAAS6E,OAAQG,EAAW,IAC5BC,OAAQ,IAGV,MAAO,CAACnF,EAAQgF,EAAcI,KAC5B,MAAM,KAAEH,EAAI,QAAE/E,EAAO,OAAEiF,GAAWnF,EAElC,GAAIoF,EAAO9E,OAASmE,EAAM,CACxB,MAAMY,EAAWJ,EAAKA,EAAKjJ,OAAS,GACpC,IAAKqJ,EACH,OAAOrF,EAIT,MAAO,CACLiF,KAFcA,EAAK5F,MAAM,EAAG4F,EAAKjJ,OAAS,GAG1CkE,QAASmF,EACTF,OAAQ,CAACjF,KAAYiF,IAIzB,GAAIC,EAAO9E,OAASqE,EAAM,CACxB,MAAMW,EAAOH,EAAO,GACpB,IAAKG,EACH,OAAOtF,EAGT,MAAMuF,EAAYJ,EAAO9F,MAAM,GAC/B,MAAO,CACL4F,KAAM,IAAIA,EAAM/E,GAChBA,QAASoF,EACTH,OAAQI,GAIZ,MAAMC,EAAaT,EAAQ7E,EAASkF,GAEpC,MA1DY,uBA0DRA,EAAO9E,KACF,CACL2E,KAAM,GACN/E,QAASsF,EACTL,OAAQ,IAlDG,0BAsDXC,EAAO9E,KACF,CACL2E,KAAM,IAAIA,EAAM/E,GAChBA,QAASsF,EACTL,OAAQ,IAIRjF,IAAYsF,EACPxF,EAGF,CACLiF,OACA/E,QAASsF,EACTL,a,6JCzFN,cACA,OAEA,OACA,QAEA,IAAYM,EAKAC,GALZ,SAAYD,GACV,qBACA,yBAFF,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAKvB,SAAYC,GACV,kCACA,wCACA,4CACA,0BACA,4CALF,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAerB,MAAMC,EAAgB,KACpB,IACE,MAAMlE,EAAQmE,aAAaC,QAAQ,SACnC,GAAa,MAATpE,EAAe,OAAO,EAC1B,MAAMqE,EAASvB,SAAS9C,EAAO,IAC/B,OAAIsE,OAAOC,MAAMF,GAAgB,EAC1BA,EACP,MAAOG,GACP,OAAO,IAIE,EAAAC,UAAalG,IACxB,IACMA,EAAM4B,cAAgB6D,EAAYU,OACpCP,aAAaQ,QAAQ,QAASpG,EAAMyB,MAAM4E,YAE5C,MAAOJ,MAKX,MAAMK,EAAiB,CAAC1E,EAA0B2E,KAChD,IAAI9E,EAAQ,EAeZ,OAdIG,IAAgB6D,EAAYe,SAAWD,IAAcb,EAAUe,oBACjEhF,EAAQ,GAER8E,IAAcb,EAAUgB,mBACvB9E,IAAgB6D,EAAYU,OAASI,IAAcb,EAAUe,qBAC7D7E,IAAgB6D,EAAYe,SAAWD,IAAcb,EAAUiB,YAC/D/E,IAAgB6D,EAAYe,SAAWD,IAAcb,EAAUkB,eAEhEnF,EAAQ,EACCG,IAAgB6D,EAAYe,SAAWd,EAAUmB,oBAC1DpF,GAAS,GACAG,IAAgB6D,EAAYU,OAASI,IAAcb,EAAUmB,sBACtEpF,GAAS,GAEJA,GAKI,EAAAqF,eAAkBP,IAA+C,CAAGjG,KAFzD,+BAEgFiG,cAI3F,EAAAQ,eAAiB,KAA4B,CAAGzG,KAFrC,oBAMxB,MAAM0E,EAA+B,CACnChD,QAAS,EACTP,MAAO,EACPK,MAAOkF,IACPpF,YAAa6D,EAAYe,SAyC3B,UAAe,EAAA1B,SAtCC,CAAC9E,EAAwBgF,EAAcI,IACjDA,EAAO9E,OAAS,EAAA2G,WACX,OAAP,wBACKjH,GAAK,CACR4B,YAAawD,EAAOxD,YACpBH,MAAO2D,EAAOxD,cAAgB6D,EAAYU,MAAQR,IAAkB,GAAK,EACzE7D,MAAOsD,EAAOxD,cAAgB6D,EAAYU,MAAQ,EAAIa,MAnBpC,oBAuBlB5B,EAAO9E,KACF,OAAP,wBACKN,GAAK,CACR8B,MAAO9B,EAAM8B,MAAQ,IAIrBsD,EAAO9E,OAAS,EAAA4G,WACX9B,EAAO+B,GAAG7G,OAAS,EAAAb,UAAUqB,OAAUsE,EAAOgC,MAAQhC,EAAOgC,KAAK9G,OAAS,EAAAb,UAAUqB,MACxF,OAAD,wBACMd,GAAK,CACRgC,QACEoD,EAAO+B,GAAG7G,OAAS,EAAAb,UAAUqB,MACzBuB,KAAKE,IAAI6C,EAAO+B,GAAGzG,MAAM1E,OAASoJ,EAAO1E,MAAM1E,OAAQ,GACvDqG,KAAKG,IAAI,EAAGxC,EAAMgC,QAAU,KAEpChC,EA3CgB,iCA8ClBoF,EAAO9E,KACF,OAAP,wBACKN,GAAK,CACRyB,MAAOzB,EAAMyB,MAAQ6E,EAAetG,EAAM4B,YAAawD,EAAOmB,aAG3DvG,I,4GCvHT,aAEA,QACA,QACA,QAQa,EAAAqH,QAAUC,EAAMC,cAAkC,MAE/D,MAAMC,EAAY,CAACC,EAA0CC,KAC3D,MAAQC,YAAaC,GAAMH,EACrBI,EAASD,EAAEE,OACXC,EAAQ,CAAEC,EAAGJ,EAAEK,QAASC,EAAGN,EAAEO,SAC7BC,EAAMP,EAAOQ,WAAW,MAC9B,IAAK,MAAMC,KAAQZ,EAAUa,OAC3B,GAAIH,aAAG,EAAHA,EAAKI,cAAcF,EAAMP,EAAMC,EAAGD,EAAMG,GAAI,CAC9C,MAAMO,EAAQf,EAAUxJ,IAAIoK,GAC5B,GAAa,MAATG,EAAe,OACnB,MAAO,CAAEA,QAAOV,WAIhBW,EAAsD,EAAGC,eAC7D,MAAMjB,EAAYJ,EAAMsB,OAA8B,IAAIC,KACpDC,EAAgBxB,EAAMsB,OAA6B,IAAIC,KACvDE,EAAsBzB,EAAMsB,OAA6B,IAAIC,MAE5DG,GAAe1B,EAAM2B,SAAsB,EAAAC,aAAa,EAAAC,gBAAgBC,QACzE,IAAEhB,EAAG,MAAEiB,EAAK,OAAEC,EAAM,gBAAEC,GAAoB,EAAAC,gBAE1CC,EAAUnC,EAAMoC,QAA+B,IAC9CL,GAAUC,GAAWlB,EACnB,CAAEA,MAAKiB,QAAOC,SAAQN,eADS,KAErC,CAACZ,EAAKiB,EAAOC,EAAQN,IAExB1B,EAAMqC,gBAAgB,IAAOF,GAAW,EAAAG,WAAWH,SAAa,EAAQ,CAACA,IAEzE,MAAMnL,EAAQgJ,EAAMoC,QAClB,IACED,GAAW,CACTA,UACA,IAAIhB,EAAOoB,GACTnC,EAAUoC,QAAQC,IAAItB,EAAMH,KAAMG,GAC9BoB,EAAOG,SAASlB,EAAcgB,QAAQC,IAAItB,EAAMH,KAAMuB,EAAOG,SAC7DH,EAAOI,eAAelB,EAAoBe,QAAQC,IAAItB,EAAMH,KAAMuB,EAAOI,gBAE/E,OAAO3B,GACLZ,EAAUoC,QAAQI,OAAO5B,GACzBQ,EAAcgB,QAAQI,OAAO5B,GAC7BS,EAAoBe,QAAQI,OAAO5B,KAGzC,CAACmB,IAGGU,EAA0B7C,EAAM8C,YAAa3C,IACjD,MAAMvF,EAAYsF,EAAUC,EAAKC,EAAUoC,SAC3C,GAAI5H,EAAW,CACb,MAAM,MAAEuG,EAAK,MAAEV,GAAU7F,EACnBmI,EAAQtB,EAAoBe,QAAQ5L,IAAIuK,EAAMH,MAChD+B,GAAOA,EAAM5B,EAAOV,KAEzB,IAEGuC,EAAoBhD,EAAM8C,YAAa3C,IAC3C,MAAMvF,EAAYsF,EAAUC,EAAKC,EAAUoC,SAC3C,GAAI5H,EAAW,CACb,MAAM,MAAEuG,EAAK,MAAEV,GAAU7F,EACnBmI,EAAQvB,EAAcgB,QAAQ5L,IAAIuK,EAAMH,MAC1C+B,GAAOA,EAAM5B,EAAOV,KAEzB,IAEH,OACE,gCACE,0BACEwC,GAAG,SACHC,MAAO,CACLC,gBAAiBzB,EAAY0B,WAC7BC,IAAK,IACLC,KAAM,IACNvB,MAAO,QACPC,OAAQ,QACRuB,SAAU,YAEZC,IAAKvB,EACLF,MAAOlK,OAAO4L,WACdzB,OAAQnK,OAAO6L,YACfhB,QAASM,EACTL,cAAeE,IAEjB,gBAAC,EAAA9C,QAAQ4D,SAAQ,CAAC3M,MAAOA,GAAQqK,KAK9B,EAAAD,aACT,UAAepB,EAAM4D,KAAKxC,I,6OCrG1B,aAEa,EAAAyC,wBAA2B/C,GAAwB/F,KAAKI,MAAmB,IAAb2F,EAAIkB,QAElE,EAAA8B,yBAA4BhD,GAAwB/F,KAAKI,MAAmB,IAAb2F,EAAIkB,QAEnE,EAAA+B,sBAAyBjD,GAAwB/F,KAAKI,MAAmB,IAAb2F,EAAIkB,QAEhE,EAAAgC,wBAA2BlD,GAAwB/F,KAAKI,MAAkB,IAAZ2F,EAAIiB,OAElE,EAAAkC,aAAe,KAAW,CAAGvD,EAAG,EAAGE,EAAG,EAAGmB,MAAO,EAAGC,OAAQ,KAQ3D,EAAAkC,kBAAqBpD,IAChC,MAAMqD,EAAmB,EAAAH,wBAAwBlD,GAC3CsD,EAAiB,EAAAL,sBAAsBjD,GACvCuD,EAAY,EAAAJ,eACZK,EAAwB,EAAAR,yBAAyBhD,GAEjDyD,EAAoBF,EAAUrC,OAA0B,EAAjBoC,EAA6C,GAAxBE,EAC5DE,EAAyC,EAAnBL,EAEtBM,EAAW1J,KAAKI,OAAO2F,EAAIiB,MAAQyC,GAAuB,GAC1DE,EAAY3J,KAAKI,OAAO2F,EAAIkB,OAASuC,GAAqB,KAG1DxC,EADgB,MACR0C,EAA2BC,EAAYD,EAAWC,EAD1C,MAEhB1C,EAFgB,MAEPyC,EAA2BC,EAFpB,MAEgCD,EAA2BC,EAEjF,MAAO,CACL3C,MAAOhH,KAAKI,MAAM4G,GAClBC,OAAQjH,KAAKI,MAAM6G,KAIV,EAAA2C,YAAc,CAAC7D,EAAqB/H,EAAcmC,KAC7D,MAAMkJ,EAAiB,EAAAL,sBAAsBjD,GACvCqD,EAAmB,EAAAH,wBAAwBlD,GAC3C8D,EAAS,EAAAX,gBACT,MAAElC,EAAK,OAAEC,GAAW,EAAAkC,kBAAkBpD,GACtC+D,EAAa9J,KAAKE,IAAIlC,EAAMK,MAAM1E,OAAQwG,GAM1C4J,EAA+B,EAAnBX,EAA+B,EAARpC,EACnCgD,EAAQD,EAAYhE,EAAIiB,OAASjB,EAAIiB,MAAQ+C,GAAa,EAAI,EAE9DE,EACJjM,EAAMkM,YAAc,EAAA/M,eAAegN,WAChB,IAAfL,EACE7C,EACA,EAAA6B,wBAAwB/C,IAAQ+D,EAAa,GAAK9C,EACpDA,EAEAoD,EACJpM,EAAMkM,YAAc,EAAA/M,eAAekN,SAChB,IAAfP,EACE7C,EACA,EAAA8B,yBAAyBhD,IAAQ+D,EAAa,GAAK7C,EACrDA,EAEN,OAAQjJ,EAAMC,MACZ,KAAK,EAAAb,UAAUmB,MACb,MAAO,CACLsH,EAAGgE,EAAO5C,OAASoC,EACnB1D,EAAGqE,EACHhD,MAAOiD,EACPhD,OAAQmD,GAEZ,KAAK,EAAAhN,UAAUqB,MACb,MAAO,CACLoH,EAAGgE,EAAO5C,OAASoC,EACnB1D,EAAGqE,EAAQZ,EAAmBpC,EAC9BA,MAAOiD,EACPhD,OAAQmD,GAEZ,KAAK,EAAAhN,UAAUc,WACb,MAAO,CACL2H,EAAGgE,EAAO5C,OAASoC,EACnB1D,EAAGqE,EAAQ,EAAIZ,EAAmB,EAAIpC,EAAQhJ,EAAM0C,OAAS0I,EAAmBpC,GAChFA,MAAOiD,EACPhD,OAAQmD,GAEZ,KAAK,EAAAhN,UAAUkN,QACb,MAAO,CACLzE,EAAGgE,EAAO5C,OAA0B,EAAjBoC,EAAqBpC,EACxCtB,EAAGqE,EAAQhM,EAAM0C,OAAS0I,EAAmBpC,GAC7CA,MAAOiD,EACPhD,OAAQmD,M,kNChGhB,aACA,OACA,OACA,QAEa,EAAAG,OAAS,uBAET,EAAAC,WAAa,CAACxM,EAAcY,KAAkC,CAAGX,KAAM,EAAAsM,OAAQ3L,OAAMZ,UAErF,EAAAyM,SAAW,yBAEX,EAAAC,aAAe,KAAsB,CAAGzM,KAAM,EAAAwM,WAE9C,EAAAE,WAAa,sBAEb,EAAAC,OAAU5M,IAAsC,CAAGC,KAAM,EAAA0M,WAAY3M,UAErE,EAAA6G,WAAa,sBAIb,EAAAgG,WAAa,CAACtM,EAAcE,KAAiC,CACxER,KAAM,EAAA4G,WACNE,KAAMxG,EACNuG,GAAIrG,EACJJ,MAAOE,EAAMF,MAAMrB,OAAO,GAAG8N,UAC7BC,QAAQ,IAIG,EAAAC,aAAe,CAACvM,EAAcF,KAAiC,CAC1EN,KAAM,EAAA4G,WACNE,KAAMtG,EACNqG,GAAIvG,EACJF,MAAOI,EAAMJ,MAAMrB,MAAM,GACzB+N,QAAQ,IAIG,EAAAE,UAAY,CAAClG,EAAaD,EAAWoG,EAAyB,QAAyB,CAClGjN,KAAM,EAAA4G,WACNE,OACAD,KACAzG,MAAO0G,EAAK1G,MAAMrB,MAAM+H,EAAK1G,MAAM8M,UAAWvM,GAASA,EAAKA,OAASsM,IACrEH,QAAQ,IAKV,MAAMK,EAEF,CACF,CAAC,EAAAxG,YAAa,CAACjH,EAAOoF,IAA8B,OAAD,wBAC9CpF,GAAK,CACRC,OAAQD,EAAMC,OAAOyN,IAAKrN,GACpBA,EAAMC,OAAS,EAAAb,UAAUc,YAAcF,EAAMC,OAAS,EAAAb,UAAUqB,MAC3D,OAAP,wBAAYT,GAAK,CAAEK,MAAO,KAExBL,EAAMC,OAAS,EAAAb,UAAUmB,MACpB,OAAP,wBAAYP,GAAK,CAAEK,MAAO0E,EAAO1E,MAAMrB,MAAM,EAAG,IAAIqO,IAAKzM,IAAS,CAAGA,OAAMmM,QAAQ,OAEjF/M,EAAMC,OAAS,EAAAb,UAAUkN,QACpB,OAAP,wBACKtM,GAAK,CACRK,MAAO0E,EAAO1E,MACXrB,MAAM,GAAK,EAAAqD,eAAerC,EAAM0C,OAAQ,GAAK,EAAAL,eAAerC,EAAM0C,OAAS1C,EAAM0C,MAAQ,GACzF2K,IAAI,CAACzM,EAAM8B,EAAO4K,KAAM,CAAG1M,OAAMmM,OAAQO,EAAE3R,SAAW+G,EAAQ,OAG9D1C,KAGX,CAAC,EAAAuM,QAAS,CAAC5M,EAAOoF,IAA0B,OAAD,wBACtCpF,GAAK,CACRC,OAAQD,EAAMC,OAAOyN,IAAKrN,GACxB,EAAAuC,UAAUvC,EAAO+E,EAAO/E,QAAU,EAAA8C,kBAAkB9C,EAAMK,MAAO0E,EAAOnE,MACpE,OAAD,wBACMZ,GAAK,CACR6B,UAAWkD,EAAOnE,KAAKA,KACvBP,MAAOL,EAAMK,MAAMgN,IAAKrK,GACrB,EAAAL,SAASK,EAAW+B,EAAOnE,MAAoB,OAAD,wBAAMoC,GAAS,CAAEuK,UAAU,IAAtCvK,KAGxChD,KAGR,CAAC,EAAAyM,UAAY9M,GAAW,OAAD,wBAClBA,GAAK,CACRC,OAAQD,EAAMC,OAAOyN,IAAKrN,GACL,MAAnBA,EAAM6B,UACF,OAAD,wBACM7B,GAAK,CACR6B,UAAW,KACXxB,MAAOL,EAAMK,MAAMgN,IAAKrK,GACrBA,EAAUuK,SAAuB,OAAD,wBAAMvK,GAAS,CAAEuK,UAAU,IAAtCvK,KAG1BhD,KAGR,CAAC,EAAA6G,YAAa,CAAClH,EAAOoF,IACpBpF,EAAMC,OAAOqD,KAAMjD,GAAU,CAAC+E,EAAOgC,KAAMhC,EAAO+B,IAAItD,SAASxD,IAC3D,OAAD,wBACML,GAAK,CACRC,OAAQD,EAAMC,OAAOyN,IAAKrN,GACxB,EAAAuC,UAAUvC,EAAO+E,EAAO+B,IACpB,OAAD,wBACM9G,GAAK,CACRK,MAAO,IACFL,EAAMK,SACN0E,EAAO1E,MAAMgN,IAAKzM,GAAU,OAAD,wBAAMA,GAAI,CAAE2M,UAAU,EAAOR,OAAQhI,EAAOgI,aAG9EhI,EAAOgC,MAAQ,EAAAxE,UAAUvC,EAAO+E,EAAOgC,MACvC,OAAD,wBACM/G,GAAK,CACRK,MAAOL,EAAMK,MAAMN,OAAQiD,IAAe,EAAAF,kBAAkBiC,EAAO1E,MAAO2C,MAE5EhD,KAGRL,EACN,CAAC,EAAAgN,YAAa,CAAChN,EAAOoF,IAAiC,OAAD,wBACjDpF,GAAK,CACRC,OAAQD,EAAMC,OAAOyN,IAAKrN,GACxB,EAAAuC,UAAUvC,EAAO+E,EAAO/E,OACpB,OAAD,wBACMA,GAAK,CACRK,MAAOL,EAAMK,MAAMgN,IAAI,CAACzM,EAAM8B,IAC5BA,EAAQ1C,EAAMK,MAAM1E,OAAS,EAAIiF,EAAO,OAAD,wBAAMA,GAAI,CAAEmM,QAAQ,OAG/D/M,MASJ2E,EAA2B,CAC/B/E,OAAQ,CACN,CACEK,KAAM,EAAAb,UAAUmB,MAChB2L,UAAW,KACX7L,MAAO,GACPqC,MAAO,EACPb,UAAW,MAEb,CACE5B,KAAM,EAAAb,UAAUqB,MAChByL,UAAW,EAAA/M,eAAegN,WAC1B9L,MAAO,GACPqC,MAAO,EACPb,UAAW,SAEV2L,MAAMzG,KAAoB,CAAEpL,OAAQ,GAAK,CAACgF,EAAG+B,KAAU,CACxDA,QACAzC,KAAM,EAAAb,UAAUkN,QAChBJ,UAAW,EAAA/M,eAAekN,SAC1BhM,MAAO,GACPwB,UAAW,WAEV2L,MAAMzG,KAAoB,CAAEpL,OAAQ,GAAK,CAACgF,EAAG+B,KAAU,CACxDA,QACAzC,KAAM,EAAAb,UAAUc,WAChBgM,UAAW,KACX7L,MAAO,GACPwB,UAAW,UAWjB,UAAe,EAAA4C,SANC,CAAC9E,EAAoBgF,EAAcI,KACjD,MAAMjH,EAAIsP,EAASrI,EAAO9E,MAC1B,OAAInC,EAAUA,EAAE6B,EAAOoF,GAChBpF,K,+GC5KI,EAAAiH,WAAa,0BAEb,EAAA2C,WAAa,CAAChI,EAA0BlB,KAAoC,CACvFJ,KAAM,EAAA2G,WACNrF,cACAlB,W,gICPF,aACA,OAEA,QACA,OACA,OACA,OACA,QASa,EAAAkJ,WAAckE,GAAoD,CAACC,EAAUC,KACxF,MAAMpM,EAAgC,MAAlBkM,EAAyB,EAAAnM,eAAeqM,KAAcF,EACpEG,EAAiBJ,MAAMzG,KAAK,EAAA1H,OAC5BgB,EAAgB,GAEtB,IAAK,IAAI5E,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAC3B,MAAMiH,EAAQ,EAAAJ,OAAO,EAAGsL,EAAejS,QACvC0E,EAAMpE,QAAQ2R,EAAe/Q,OAAO6F,EAAO,IAG7CgL,EAAS,EAAAnE,WAAehI,EAAalB,KAG1B,EAAAwN,UAA6B,CAACC,EAAcC,IAAgB,CAACL,EAAUC,KAClF,GAAmB,MAAfI,GAAuBA,EAAYR,SAAU,OAAOG,EAAS,EAAAhB,gBAEjE,MAAM7K,EAAY,EAAAD,aAAa+L,KAC/B,GAAiB,MAAb9L,GAAqBkM,IAAgBA,EAAYhB,OAAQ,OAAOW,EAAS,EAAAlB,WAAWsB,EAAcC,IAEtG,GAAID,EAAa7N,OAAS,EAAAb,UAAUc,YA2BpC,GAfI4N,EAAa7N,OAAS,EAAAb,UAAUkN,UACjB,MAAbzK,GAAqBkM,GAAeA,EAAYhB,SAClDW,EAAS,EAAAlJ,cACTkJ,EAAS,EAAAjH,eAAe,EAAApB,UAAUiB,aAClCoH,EAAS,EAAAd,OAAOkB,KAED,MAAbjM,GAAqB,EAAAmC,YAAYnC,EAAUjB,KAAMmN,KACnDL,EAAS,EAAAhB,gBACTgB,EAAS,EAAAlJ,cACL3C,EAAU7B,MAAMC,OAAS,EAAAb,UAAUqB,OAAOiN,EAAS,EAAAjH,eAAe,EAAApB,UAAUkB,iBAC5E1E,EAAU7B,MAAMC,OAAS,EAAAb,UAAUc,YAAYwN,EAAS,EAAAjH,eAAe,EAAApB,UAAUmB,sBACrFkH,EAAS,EAAAT,UAAUpL,EAAU7B,MAAO8N,EAAcjM,EAAUjB,SAI5DkN,EAAa7N,OAAS,EAAAb,UAAUmB,MAAO,CACzC,GAAI,EAAAuB,mBAAmB6L,KAAa,OAChC9L,GAAW6L,EAAS,EAAAhB,gBACxB,MAAMjM,EAAQ,EAAAD,SAASmN,KACjBpN,EAAQ,EAAAD,SAASqN,KACvBD,EAAS,EAAAlJ,cACLjE,EAAMF,MAAM1E,OAAS,EACvB+R,EAAS,EAAAb,WAAWtM,EAAOE,KAE3BiN,EAAS,EAAAV,aAAavM,EAAOF,IAC7BmN,EAAS,EAAAhH,wBArCb,CACE,MAAMxG,EAAc2B,GAAa,EAAAnB,mBAAmBiN,IAAY9L,EAAUjB,OAAU,KAChFV,GAAc2B,IAChB6L,EAAS,EAAAhB,gBACTgB,EAAS,EAAAlJ,cACL3C,EAAU7B,MAAMC,OAAS,EAAAb,UAAUqB,OAAOiN,EAAS,EAAAjH,eAAe,EAAApB,UAAUgB,oBAC5ExE,EAAU7B,MAAMC,OAAS,EAAAb,UAAUkN,SAASoB,EAAS,EAAAjH,eAAe,EAAApB,UAAUe,sBAClFsH,EAAS,EAAAT,UAAUpL,EAAU7B,MAAOE,EAAY2B,EAAUjB,UAmCnD,EAAAoN,gBAAmC,CAAChO,EAAOgD,IAAc,CAAC0K,EAAUC,KAC/E,GACE3N,EAAMC,OAAS,EAAAb,UAAUc,YACzBF,EAAMC,OAAS,EAAAb,UAAUmB,OACZ,MAAbyC,GACkB,MAAlBA,EAAUpC,KAEV,OAGF,MAAMV,EAAa,EAAAQ,mBAAmBiN,IAAY3K,EAAUpC,MACvDV,IAELwN,EAAS,EAAAlJ,cACLxE,EAAMC,OAAS,EAAAb,UAAUqB,OAAOiN,EAAS,EAAAjH,eAAe,EAAApB,UAAUgB,oBAClErG,EAAMC,OAAS,EAAAb,UAAUkN,SAASoB,EAAS,EAAAjH,eAAe,EAAApB,UAAUe,sBACxEsH,EAAS,EAAAT,UAAUjN,EAAOE,EAAY8C,EAAUpC,OAChD8M,EAAS,EAAAhB,mB,gJCjGX,aAEA,QACA,OAgDA,IAAIuB,EALS,EAAAC,OAAS,EAAGtN,MAAQrB,OAAMtB,SAASsP,cAC9C,GAAGhO,KAAQtB,MAAUsP,IAAY,GAAOvH,aAE7B,EAAAmI,UAAoC,IAAI3F,IAIxC,EAAAe,WAAcH,IACzB,MAAM,MAAEJ,EAAK,OAAEC,GAAW,EAAAkC,kBAAkB/B,GAC5C,EAAA+E,UAAUzE,IAAI,SAAU,EAAA0E,mBAAmBhF,IAC3C,EAAA+E,UAAUzE,IAAI,QAAS,EAAA2E,kBAAkBjF,IACzC,EAAA+E,UAAUzE,IAAI,QAAS,EAAA4E,kBAAkBlF,IACzC,EAAA/J,MAAMkP,QAAS3N,IACb,EAAAuN,UACGzE,IAAI,EAAAwE,OAAO,CAAEtN,OAAM2M,UAAU,IAAS,EAAAiB,iBAAiBpF,EAAS,CAAExI,OAAM2M,UAAU,KAClF7D,IAAI,EAAAwE,OAAO,CAAEtN,OAAM2M,UAAU,IAAU,EAAAiB,iBAAiBpF,EAAS,CAAExI,OAAM2M,UAAU,OAGxFU,EAAKQ,SAASC,cAAc,UAC5BT,EAAGjF,MAAQA,EACXiF,EAAGhF,OAASA,EACZG,EAAQrB,IAAI4G,UAAU,EAAG,EAAG3F,EAAQ,EAAGC,EAAS,IAKrC,EAAA2F,kBAAoB,CAACxF,EAAyBjO,EAAiBwM,EAAWE,KACrF,MAAMgH,EAAOZ,EAAGjG,WAAW,MAC3B6G,WAAMC,aAAa3T,EAAM,EAAG,GAC5BiO,EAAQrB,IAAIgH,UAAUd,EAAItG,EAAGE,K,6HC3E/B,MAAMmH,EAAexB,MAAMzG,KAAqB,CAAEpL,OAAQ,KAAO,CAACsT,EAAGC,IAAMA,GAM9D,EAAAC,aAAe,CAACpH,EAA+BqH,EAAcC,KACxEtH,EAAIqH,KAAOA,EACJrH,EAAIuH,YAAYD,GAAMrG,OAGlB,EAAAuG,cAAgB,CAACxH,EAA+BqH,KAC3DrH,EAAIqH,KAAOA,EACJrH,EAAIuH,YAAY,KAAKtG,OAG9B,MAAMwG,EAAiB,CACrBzH,EACA0H,EACAJ,EACAnN,EACAC,KAEA,MAAMO,EAAQV,KAAKI,OAAOD,EAAMD,GAAO,GACjCkN,EAAUJ,EAAatM,GAAhB,gBACPsG,EAAQ,EAAAmG,aAAapH,EAAKqH,EAAMC,GAChCpG,EAAS,EAAAsG,cAAcxH,EAAKqH,GAClC,OAAIlN,EAAMC,EAAYiN,EAClBK,EAAYzG,EAAOC,GAAgBuG,EAAezH,EAAK0H,EAAaJ,EAAMnN,EAAKQ,EAAQ,GACpF8M,EAAezH,EAAK0H,EAAaJ,EAAM3M,EAAQ,EAAGP,IAG9C,EAAAuN,OAAS,CAAC3H,EAA+B0H,EAA0BJ,IAC9EG,EAAezH,EAAK0H,EAAaJ,EAAM,EAAGL,EAAarT,OAAS,I,kGCjClE,aACA,OAOa,EAAAgU,WAAa,CAACC,EAAcpG,EAAoB,M,QAC3D,MAAMqG,EAAc5I,EAAM6I,WAAW,EAAA9I,SAC/B+I,EAAiB9I,EAAMsB,QAAO,GAC9ByH,EAAY/I,EAAMsB,OAAiC,QAA3B,EAACsH,aAAW,EAAXA,EAAazG,QAAQJ,aAAK,QAAI,GACvDiH,EAAahJ,EAAMsB,OAAkC,QAA5B,EAACsH,aAAW,EAAXA,EAAazG,QAAQH,cAAM,QAAI,GAM/DhC,EAAMiJ,UAAU,KACTL,IACLE,EAAetG,WACZwG,EAAWxG,UAAYoG,EAAYzG,QAAQH,QAAU+G,EAAUvG,UAAYoG,EAAYzG,QAAQJ,QAChGiH,EAAWxG,QAAU,GACrBuG,EAAUvG,QAAU,KAErB,CAACoG,IAEJ5I,EAAMiJ,UAAU,KACd,GAAmB,MAAfL,EAAqB,OACzB,MAAM,IAAEM,EAAG,OAAEC,EAAM,QAAEhH,GAAYyG,GAC3B,IAAE9H,GAAQqB,EAEVhB,EAAQwH,EAAKxG,GACnB,OAAa,MAAThB,GACJ+H,EAAI/H,EAAOoB,GAEJ,KACL4G,EAAOhI,EAAMH,MACT8H,EAAetG,SACjB1B,EAAI4G,UAAUvG,EAAMiI,IAAI1I,EAAGS,EAAMiI,IAAIxI,EAAGO,EAAMiI,IAAIrH,MAAOZ,EAAMiI,IAAIpH,QAErE8G,EAAetG,SAAU,SAR3B,M,+ECjCJ,aACA,QACA,QAEA,QAIE6G,EAAQC,QAAQ,CACd,gBACED,EAAQE,eAEV,YACE1R,OAAO2R,SAASC,YAKtBC,EAASC,OAAO,gBAAC,UAAG,MAAKnC,SAASoC,eAAe,U,gGClBjD,aAEA,OAEA,QACA,QACA,QAEMC,EAAgB,KACpB,MAAMC,EAAQ,YAKd,OAFArD,EAFiBqD,EAAMrD,UAEd,EAAAnE,cAGP,gBAAC,EAAAqB,SAAQ,CAACmG,MAAOA,GACf,gBAAC,UAAS,QAKP,EAAAD,MAET,UAAe7J,EAAM4D,KAAKiG,I,mFCvB1B,aACA,QAEA,GADA,MACA,OACA,QACA,OACA,OAEA,UAAe,KACb,MAAME,EAAa,GAEnBA,EAAW/U,KAAK,WAahB,MAAM8U,EAAQ,EAAAE,YAAY,eAAS,EAAQ,EAAAC,mBAAmBF,IAE9D,OADA,UAAUD,EAAO,EAAA7P,aAAeE,GAA0B,EAAAyE,UAAUzE,IAC7D2P,I,gFC1BT,aACA,QACA,OAUA,UAAe,EAAAI,gBAA0C,CAAEvR,OAAA,UAAQuB,UAAA,a,gFCZnE,aACA,QACA,OACA,QACA,OACA,OACA,QAEA,OACA,QAkCA,UAAe,EAAAiQ,IAAInK,EAAM4D,KAhCG,KAC1B,MAAM6C,EAAW,EAAA2D,cACXzR,EAAS,EAAA0R,YAAY,EAAA7R,cACrBgC,EAAQ,EAAA6P,YAAY,EAAA9P,UACpBG,EAAU,EAAA2P,YAAY,EAAA5P,YAe5B,OAbAuF,EAAMiJ,UAAU,KACd,MAAMqB,EAAWhK,IACG,KAAdA,EAAEiK,UACFjK,EAAEkK,SAAWlK,EAAEmK,SACjBhE,EAAS,EAAAnJ,QACAgD,EAAEkK,SACX/D,EAAS,EAAArJ,UAIb,OADAoK,SAASkD,iBAAiB,UAAWJ,GAC9B,IAAM9C,SAASmD,oBAAoB,UAAWL,IACpD,CAAC7D,IAGF,2BACE,gBAAC,UAAkB,MACnB,gBAAC,UAAU,KACT,gBAAC,UAAM,MACN9N,EAAOyN,IAAKrN,GACX,gBAAC,UAAY,CAACzB,IAAK,GAAGyB,EAAMC,QAAQD,EAAM0C,QAAS1C,MAAOA,EAAO2B,QAASA,EAASF,MAAOA,W,+ECpCpG,aACA,OACA,QACA,OA8CA,UAAewF,EAAM4D,KA5CO,KAC1B,MAAMJ,EAAMxD,EAAMsB,OAAuB,MACnCsJ,EAAe5K,EAAMsB,SACrBuJ,EAAS,EAAAR,YAAY,EAAAnR,YACrB4R,EAAUD,EAAS,GAAK,OAyB9B,OAvBA7K,EAAMiJ,UAAU,KACd,GAAmB,MAAfzF,EAAIhB,QAAiB,OACzBoI,EAAapI,QAAU,IAAIuI,EAAgBvH,EAAIhB,SAQ/C,OAFAgF,SAASkD,iBAAiB,UAJKM,I,MACV,KAAfA,EAAGT,UAAoC,QAApB,EAAAK,EAAapI,eAAO,SAAEyI,UAKxC,K,MACe,QAApB,EAAAL,EAAapI,eAAO,SAAEtF,YAEvB,CAACsG,EAAKqH,IAET7K,EAAMiJ,UAAU,K,QACV4B,EACkB,QAApB,EAAAD,EAAapI,eAAO,SAAEyI,OAEF,QAApB,EAAAL,EAAapI,eAAO,SAAE0I,SAEvB,CAACL,IAGF,uBACE3H,MAAO,CACL4H,UACAzH,IAAK,IACLC,KAAM,IACNvB,MAAO,QACPC,OAAQ,QACRuB,SAAU,YAEZC,IAAKA,O,8BC5CX,IAAY3B,E,yFAAZ,SAAYA,GACV,mBACA,qBAFF,CAAYA,EAAA,EAAAA,kBAAA,EAAAA,gBAAe,KAkBd,EAAAD,aAA0D,CACrE,CAACC,EAAgBC,MAAO,CACtBsB,WAAY,OACZ+H,WAAY,UACZC,OAAQ,OACRC,SAAU,OACVC,aAAc,OACdC,WAAY,OACZC,MAAO,OACPC,IAAK,OACLnF,SAAU,OACVoF,WAAY,QAEd,CAAC7J,EAAgB8J,OAAQ,CACvBvI,WAAY,OACZ+H,WAAY,OACZC,OAAQ,OACRC,SAAU,OACVC,aAAc,OACdC,WAAY,OACZC,MAAO,OACPC,IAAK,UACLnF,SAAU,SACVoF,WAAY,S,sMCzChB,aAEA,OACA,QAEA,OAqCA,IAAKE,EArBQ,EAAAC,WAAa,EAAGnL,IAAGE,IAAGmB,QAAOC,UAAe8J,EAAS,GAAIC,EAAU,KAC9E,MAAM/K,EAAO,IAAIgL,OAEXC,EAAKvL,EAAIqL,EACTG,EAAKtL,EAAImL,EACTI,EAAKpK,EAAkB,EAAVgK,EACbK,EAAKpK,EAAmB,EAAV+J,EAYpB,OAVA/K,EAAKqL,OAAOJ,EAAKH,EAAQI,GACzBlL,EAAKsL,OAAOL,EAAKE,EAAKL,EAAQI,GAC9BlL,EAAKuL,iBAAiBN,EAAKE,EAAID,EAAID,EAAKE,EAAID,EAAKJ,GACjD9K,EAAKsL,OAAOL,EAAKE,EAAID,EAAKE,EAAKN,GAC/B9K,EAAKuL,iBAAiBN,EAAKE,EAAID,EAAKE,EAAIH,EAAKE,EAAKL,EAAQI,EAAKE,GAC/DpL,EAAKsL,OAAOL,EAAKH,EAAQI,EAAKE,GAC9BpL,EAAKuL,iBAAiBN,EAAIC,EAAKE,EAAIH,EAAIC,EAAKE,EAAKN,GACjD9K,EAAKsL,OAAOL,EAAIC,EAAKJ,GACrB9K,EAAKuL,iBAAiBN,EAAIC,EAAID,EAAKH,EAAQI,GAC3ClL,EAAKwL,YACExL,GAGT,SAAK4K,GACH,yBACA,uBAFF,CAAKA,MAAY,KAKJ,EAAAa,kBAAoB,CAACtK,GAA2BxI,OAAMmM,aACjE,GAAIA,EAAQ,MAAO,GAEnB,MAAM,IAAEhF,GAAQqB,GACRJ,MAAO2K,EAAW1K,OAAQ2K,GAAe,EAAAzI,kBAAkB/B,GAC7DyK,EAAe,EAAA7I,sBAAsB5B,GACrC0K,EAAc,EAAA7I,wBAAwB7B,GAEtC2K,EAAc/R,KAAKI,MAAkB,GAAZuR,GACzBK,EAAqB/T,GACzB,EAAAyP,OACE3H,EACA,CAACiB,EAAeC,IACdhJ,IAAS4S,EAAaoB,OAClBjL,EAAQ+K,EACR,EAAAnQ,MAAMhD,GACNoI,EAAQ2K,EAAwC,EAA5B3R,KAAKI,MAAMuR,EAAY,GAC3C3K,EAAQhH,KAAKI,MAAMuR,EAAY,IAAM1K,EAASjH,KAAKI,MAAMwR,EAAa,IAC5E3T,IAAS4S,EAAaoB,OAAS,KAAO,KAGpCC,EAA+C,CACnD,CAACrB,EAAaoB,QAASD,EAAkBnB,EAAaoB,QACtD,CAACpB,EAAasB,SAAUH,EAAkBnB,EAAasB,UAOnDC,EAAeN,EAAc,EAC7BO,EAAeR,EAAe,EAC9BS,EAAcR,EAAc,EAC5BS,EAAcT,EAAc,EALb,EAAAvE,cAAcxH,EAAKmM,EAAUrB,EAAaoB,UAOzD,KAAE1U,EAAI,MAAEtB,GAAU2C,EAGlB4T,EAAY,CAChB,CAAE7M,EAAGyM,EAAcvM,EAAGwM,EAAcI,MAAOxW,GAC3C,CAAE0J,EAAG2M,EAAazM,EAAG0M,EAAaE,MAAOlV,IACzCmV,OAAO,CAAC7J,EAAM4J,KACd5J,EAAK5O,KAAK,OAAD,wBAEFwY,GAAK,CACRE,SAAS,EACTC,UAAW,OACXC,aAAc,MACdzF,KAAM8E,EAAUrB,EAAaoB,UAAO,+BAGjCQ,GAAK,CACRE,SAAS,EACTC,UAAW,OACXC,aAAc,MACdzF,KAAM8E,EAAUrB,EAAaoB,WAG1BpJ,GACN,IAMGiK,EAA8B,GAGlC,CACE,EAAA7V,UAAU+B,IACV,EAAA/B,UAAU8V,MACV,EAAA9V,UAAU+V,KACV,EAAA/V,UAAUgW,KACV,EAAAhW,UAAU4E,KACV,EAAA5E,UAAU6E,MACV,EAAA7E,UAAU8E,MACVP,SAASvF,IAEX6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,IAGlB,CAAC,EAAA5I,UAAUiW,IAAK,EAAAjW,UAAU8V,OAAOvR,SAASvF,IAC5C6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,IAIpC,CACE,EAAA5I,UAAUkW,KACV,EAAAlW,UAAU+V,KACV,EAAA/V,UAAUmW,IACV,EAAAnW,UAAUoW,MACV,EAAApW,UAAUqW,MACV,EAAArW,UAAUgW,KACV,EAAAhW,UAAUsW,KACV/R,SAASvF,IAEX6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,IAGlE,CAAC,EAAA5I,UAAUmW,IAAK,EAAAnW,UAAUoW,MAAO,EAAApW,UAAUqW,OAAO9R,SAASvF,IAC7D6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,IAGlC,CAAC,EAAA5I,UAAUoW,MAAO,EAAApW,UAAUsW,IAAK,EAAAtW,UAAUqW,OAAO9R,SAASvF,IAC7D6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,IAGlB,CAAC,EAAA5I,UAAUgW,KAAM,EAAAhW,UAAUsW,KAAK/R,SAASvF,IAC3C6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,GAAK,CAAEF,EAAG,EAAGE,EAAG,IAGlE,CAAC,EAAA5I,UAAUsW,IAAK,EAAAtW,UAAUqW,OAAO9R,SAASvF,IAC5C6W,EAAI7Y,KAAK,CAAE0L,EAAG,EAAGE,EAAG,IAGtB,MAAM2N,EAAU3N,IACd,OAAQA,GACN,KAAK,EACL,KAAK,EACH,MAAoB,GAAb+L,EACT,KAAK,EACL,KAAK,EACH,MAAoB,GAAbA,EACT,KAAK,EACL,KAAK,EACH,MAAoB,GAAbA,EACT,KAAK,EACH,MAAoB,GAAbA,IAIP6B,EAAW9N,IACf,OAAQA,GACN,KAAK,EACH,MAAmB,IAAZgM,EACT,KAAK,EACH,MAAmB,GAAZA,EACT,KAAK,EACH,MAAmB,IAAZA,IAIP+B,EAAgB/N,IACpB,OAAQA,GACN,KAAK,EACH,MAAO,OACT,KAAK,EACH,MAAO,SACT,KAAK,EACH,MAAO,UAgBb,OAZAmN,EAAIvG,QAAQ,EAAG5G,IAAGE,QAChB2M,EAAUvY,KAAK,CACb0L,EAAG8N,EAAQ9N,GACXE,EAAG2N,EAAO3N,GACV4M,MAAOlV,EACPqV,UAAWc,EAAa/N,GACxBkN,aAAc,SACdF,QAAS9M,EAAI,EACbuH,KAAM8E,EAAUrB,EAAasB,aAI1BK,GAGI,EAAAnG,kBAA8BjF,IACzC,MAAM,IAAErB,EAAG,YAAEY,GAAgBS,GACvB,MAAEJ,EAAK,OAAEC,GAAW,EAAAkC,kBAAkB/B,GACtCiH,EAAM,CAAE1I,EAAG,EAAGE,EAAG,EAAGmB,QAAOC,UAOjC,OANAlB,EAAI4G,UAAU,EAAG,EAAG3F,EAAOC,GAC3BlB,EAAI4N,UAAYhN,EAAYyJ,WAC5BrK,EAAI6N,SAASvF,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QAC1ClB,EAAI8N,UAAY,GAChB9N,EAAI+N,YAAcnN,EAAY6J,WAC9BzK,EAAIgO,WAAW1F,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QACrClB,EAAIiO,aAAa3F,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,SAG1C,EAAAmF,mBAA+BhF,IAC1C,MAAM,IAAErB,EAAG,YAAEY,GAAgBS,GACvB,MAAEJ,EAAK,OAAEC,GAAW,EAAAkC,kBAAkB/B,GACtCiH,EAAM,CAAE1I,EAAG,EAAGE,EAAG,EAAGmB,QAAOC,UAOjC,OANAlB,EAAI4G,UAAU0B,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QAC3ClB,EAAI+N,YAAcnN,EAAY6J,WAC9BzK,EAAI8N,UAAY,EAChB9N,EAAIkO,OAAO,EAAAnD,WAAWzC,EAAK,KAC3BtI,EAAI4N,UAAYhN,EAAY2J,SAC5BvK,EAAImO,KAAK,EAAApD,WAAWzC,EAAK,GAAI,KACtBtI,EAAIiO,aAAa3F,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,SAG1C,EAAAuF,iBAA4B,CAACpF,EAAyBxI,KACjE,MAAM,IAAEmH,EAAG,YAAEY,GAAgBS,GACvB,MAAEJ,EAAK,OAAEC,GAAW,EAAAkC,kBAAkB/B,GACtCiH,EAAM,CAAE1I,EAAG,EAAGE,EAAG,EAAGmB,QAAOC,UAEjClB,EAAI4G,UAAU0B,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QAC3ClB,EAAI+N,YAAcnN,EAAY6J,WAC9BzK,EAAI8N,UAAY,EAChB9N,EAAIkO,OAAO,EAAAnD,WAAWzC,EAAK,KAE3BtI,EAAI4N,UAAY/U,EAAK2M,SAAW5E,EAAY4E,SAAW5E,EAAY0J,OACnEtK,EAAImO,KAAK,EAAApD,WAAWzC,EAAK,GAAI,KAE7B,IAAK,MAAMoE,KAAS,EAAAf,kBAAkBtK,EAASxI,GAC7CmH,EAAI4N,UAAY,EAAAtS,MAAMzC,EAAKA,MAAQ+H,EAAY+J,IAAM/J,EAAY8J,MACjE1K,EAAI6M,UAAYH,EAAMG,UACtB7M,EAAI8M,aAAeJ,EAAMI,aACzB9M,EAAIqH,KAAOqF,EAAMrF,KACbqF,EAAME,UACR5M,EAAIoO,OACJpO,EAAIqO,UAAUpN,EAAOC,GACrBlB,EAAIsO,OAAOrU,KAAKsU,KAElBvO,EAAIwO,SAAS9B,EAAMA,MAAOA,EAAM9M,EAAI0I,EAAI1I,GAAK8M,EAAME,SAAW,EAAI,GAAIF,EAAM5M,EAAIwI,EAAIxI,GAAK4M,EAAME,SAAW,EAAI,IAC1GF,EAAME,SAAS5M,EAAIyO,UAEzB,OAAOzO,EAAIiO,aAAa3F,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,SAG1C,EAAAqF,kBAA8BlF,IACzC,MAAM,IAAErB,EAAG,YAAEY,GAAgBS,GACvB,MAAEJ,EAAK,OAAEC,GAAW,EAAAkC,kBAAkB/B,GACtCiH,EAAM,CAAE1I,EAAG,EAAGE,EAAG,EAAGmB,QAAOC,UASjC,OARAlB,EAAI4G,UAAU0B,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QAC3ClB,EAAI4N,UAAYhN,EAAYyJ,WAC5BrK,EAAImO,KAAK,EAAApD,WAAWzC,IACpBtI,EAAIqH,KAAO,kBACXrH,EAAI6M,UAAY,SAChB7M,EAAI8M,aAAe,SACnB9M,EAAI4N,UAAYhN,EAAYgK,WAC5B5K,EAAIwO,SAAS,IAAKlG,EAAIrH,MAAQ,EAAGqH,EAAIpH,OAAS,GACvClB,EAAIiO,aAAa3F,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,U,qGC1RvD,aAUa,EAAAE,cAAgB,KAC3B,MAAO3B,EAAQiP,GAAaxP,EAAM2B,SAAmC,MAC/DM,EAAkBjC,EAAM8C,YAAavC,GAA8BA,GAAUiP,EAAUjP,GAAS,IAEhGkP,EAAU,KAAM,CAAG1N,MAAOlK,OAAO4L,WAAYzB,OAAQnK,OAAO6L,eAE3DgM,EAAMC,GAAW3P,EAAM2B,WAE9B3B,EAAMiJ,UAAU,KACd,IAAK1I,EAAQ,OAEb,GAAW,MADCA,EAAOQ,WAAW,MACb,OACjB,IAAI6O,EACJ,MAAMC,EAAa,KACbD,GAAKE,aAAaF,GACtBA,EAAM/X,OAAOkY,WAAW,IAAMJ,EAAQF,KAAY,MAGpD,OADA5X,OAAO6S,iBAAiB,SAAUmF,GAC3B,KACLhY,OAAO8S,oBAAoB,SAAUkF,MAezC,OAXe7P,EAAMoC,QACnB,IAAO,OAAD,QACJH,mBACI1B,GAAU,OAAJ,QACRO,IAAKP,EAAOQ,WAAW,OACnB2O,UAAQD,MAGhB,CAACC,EAAMzN,EAAiB1B,M,oGCzC5B,aACA,OACA,QACA,OACA,OACA,QAEA,QACA,OAEMyP,EAID,EAAGjX,QAAOyB,QAAOE,cACpB,MAAM+L,EAAW,EAAA2D,cACXxB,EAAc5I,EAAM6I,WAAW,EAAA9I,SAE/BkQ,EAAc,EAAA7N,QAClB,IAAMwG,GAAe,EAAAsH,uBAAuBtH,EAAYzG,QAASpJ,EAAO,CAAEyB,QAAOE,YACjF,CAACkO,EAAa7P,EAAOyB,EAAOE,IAGxBiI,EAAgB3C,EAAM8C,YAC1B,CAAC3B,EAAiBV,KAChB,GAAmB,MAAfmI,GAAsC,MAAfqH,EAAqB,OAChD,MAAME,EAAOpX,EAAMkM,YAAc,EAAA/M,eAAegN,WAAa,IAAM,IAC7D9L,EAAQL,EAAMK,MAAMrB,OAAOkY,EAAY/U,KACvCO,EAAQV,KAAKE,IAAI7B,EAAM1E,OAAS,EAAGqG,KAAKI,OAAOsF,EAAM0P,GAAQF,EAAY7G,IAAI+G,IAASF,EAAYG,QACpGrX,EAAMC,OAAS,EAAAb,UAAUqB,OAASiC,IAAUrC,EAAM1E,OAAS,GAAG+R,EAAS,EAAAM,gBAAgBhO,EAAOK,EAAMqC,MAE1G,CAACgL,EAAUmC,EAAaqH,EAAalX,IAGjC2J,EAAU1C,EAAM8C,YACpB,CAAC3B,EAAiBV,KAChB,GAAmB,MAAfmI,GAAsC,MAAfqH,EAAqB,OAChD,MAAME,EAAOpX,EAAMkM,YAAc,EAAA/M,eAAegN,WAAa,IAAM,IAC7D9L,EAAQL,EAAMK,MAAMrB,OAAOkY,EAAY/U,KACvCO,EAAQV,KAAKE,IAAI7B,EAAM1E,OAAS,EAAGqG,KAAKI,OAAOsF,EAAM0P,GAAQF,EAAY7G,IAAI+G,IAASF,EAAYG,QACpGrX,EAAMC,OAAS,EAAAb,UAAUqB,OAASiC,IAAUrC,EAAM1E,OAAS,GAAG+R,EAAS,EAAAG,UAAU7N,EAAOK,EAAMqC,MAEpG,CAACgL,EAAUmC,EAAaqH,EAAalX,IAKvC,OAFA,EAAA2P,WAAYvG,GAAY,EAAAkO,UAAUlO,EAAS8N,GAAc,CAAEvN,UAASC,kBAE7D,MAGA,EAAAqN,eACT,UAAehQ,EAAM4D,KAAKoM,I,0HCnD1B,aACA,QACA,OAca,EAAAE,uBAAyB,CACpC/N,EACApJ,EACAuX,KAEA,MAAMpV,EACJnC,EAAMC,OAAS,EAAAb,UAAUmB,OAASP,EAAMC,OAAS,EAAAb,UAAUc,WACvD,EACAF,EAAMC,OAAS,EAAAb,UAAUqB,MACzB8W,EAAK5V,SAAW,EAChB3B,EAAMK,MAAM1E,OAEZ0U,EAAM,EAAAzE,YAAYxC,EAASpJ,EAAOmC,GAElCkV,EACJrX,EAAMkM,YAAc,EAAA/M,eAAegN,WAAa,EAAArB,wBAAwB1B,GAAW,EAAA2B,yBAAyB3B,GAE9G,MAAO,CACLpJ,QACAyB,MAAO8V,EAAK9V,MACZE,QAAS4V,EAAK5V,QACd0V,QACAhH,MACAlO,QAIS,EAAAmV,UAA8C,CAAClO,EAAS8N,KACnE,GAAmB,MAAfA,EAAqB,OAAO,KAChC,MAAM,MAAElX,EAAK,MAAEyB,EAAK,IAAEU,EAAG,MAAEkV,EAAK,IAAEhH,GAAQ6G,EACpC7W,EAAQL,EAAMK,MAAMrB,OAAOmD,GAE3B8F,EAAO,IAAIgL,OACjBhL,EAAKuP,KAAKnH,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QACvChB,EAAKwL,YAEL,MAAMgE,EAAyB,IAAjBpX,EAAM1E,OACd+b,EAAQ1X,EAAMC,OAAS,EAAAb,UAAUmB,OAASkX,GAAmB,IAAVhW,EACnDkW,EAAW,GAEbD,EAAOC,EAAS1b,KAAK,CAAEd,KAAM,EAAAgT,UAAUtQ,IAAI,SAAU8J,EAAG0I,EAAI1I,EAAGE,EAAGwI,EAAIxI,IACjE4P,EAAOE,EAAS1b,KAAK,CAAEd,KAAM,EAAAgT,UAAUtQ,IAAI,SAAU8J,EAAG0I,EAAI1I,EAAGE,EAAGwI,EAAIxI,IAE7ExH,EAAMkO,QAAQ,CAAC3N,EAAMnF,KACnB,MAAMmc,EAAUhX,EAAKmM,OAAS,EAAAoB,UAAUtQ,IAAI,UAAY,EAAAsQ,UAAUtQ,IAAI,EAAAqQ,OAAOtN,IAC7E,GAAIgX,EAAS,CACX,MAAMjQ,EAAI3H,EAAMkM,YAAc,EAAA/M,eAAegN,WAAa1Q,EAAI4b,EAAQ,EAChExP,EAAI7H,EAAMkM,YAAc,EAAA/M,eAAegN,WAAa,EAAI1Q,EAAI4b,EAClEM,EAAS1b,KAAK,CAAEd,KAAMyc,EAASjQ,EAAG0I,EAAI1I,EAAIA,EAAGE,EAAGwI,EAAIxI,EAAIA,OAI9D,IAAK,MAAM,KAAE1M,EAAI,EAAEwM,EAAC,EAAEE,KAAO8P,EAAUxc,GAAQ,EAAAyT,kBAAkBxF,EAASjO,EAAMwM,EAAGE,GACnF,MAAO,CAAEI,OAAMoI,S,8FCrEjB,aACA,OACA,OACA,OACA,QACA,QACA,QACA,OACA,OAEMwH,EAAmB,KACvB,MAAMnK,EAAW,EAAA2D,cACXxB,EAAc5I,EAAM6I,WAAW,EAAA9I,SAC/BzF,EAAc,EAAA+P,YAAY,EAAAhQ,gBAC1BwW,EAAe,EAAAxG,YAAY,EAAAjQ,UAE3B0W,EAAgB9Q,EAAMoC,QAC1B,IAAO9H,IAAgB,EAAA6D,YAAYU,MAAQ,EAAAV,YAAYe,QAAU,EAAAf,YAAYU,MAC7E,CAACvE,IAGGyW,EAAQ/Q,EAAMoC,QAAQ,KAC1B,GAAmB,MAAfwG,EAAqB,OAAO,KAEhC,MAAMoI,EAAU,EAAAC,uBAAuBrI,EAAYzG,QAAS,CAC1DzB,EAAG,EACHE,EAAG,EACHoB,OAAQ,GACRkP,QAAS,EACTC,MAAO,WACPC,QAAQ,IAGJC,EAAa,EAAAJ,uBAAuBrI,EAAYzG,QAAS,CAC7DzB,EAAGsQ,EAAQ5H,IAAI1I,EAAIsQ,EAAQ5H,IAAIrH,MAAQ,EAAAiC,wBAAwB4E,EAAYzG,SAC3EvB,EAAG,EACHoB,OAAQ,GACRkP,QAAS,EACTC,MAAO,aAAa,EAAAhT,YAAY2S,GAChCM,QAAQ,IAGJjX,EAAQ,EAAA8W,uBAAuBrI,EAAYzG,QAAS,CACxDzB,EAAG,EACHE,EAAG,EACHoB,OAAQ,GACRkP,QAAS,EACTC,MAAO,UAAUN,EACjBO,QAAQ,IAGJE,EAAU,EAAAL,uBAAuBrI,EAAYzG,QAAS,CAC1DzB,EAAG,EACHE,EAAG,EACHoB,OAAQ,GACRkP,QAAS,EACTC,MAAO,QACPC,QAAQ,IAaV,OATAC,EAAWjI,IAAI1I,EAAIsQ,EAAQ5H,IAAI1I,EAAIsQ,EAAQ5H,IAAIrH,MAAQ,EAAAiC,wBAAwB4E,EAAYzG,SAG3FhI,EAAMiP,IAAI1I,EAAIkI,EAAYzG,QAAQJ,MAAQ5H,EAAMiP,IAAIrH,MAAQ,EAAAiC,wBAAwB4E,EAAYzG,SAGhGmP,EAAQlI,IAAI1I,EAAIkI,EAAYzG,QAAQJ,MAAQuP,EAAQlI,IAAIrH,MAAQ,EAAAiC,wBAAwB4E,EAAYzG,SACpGmP,EAAQlI,IAAIxI,EAAIgI,EAAYzG,QAAQH,OAASsP,EAAQlI,IAAIpH,OAAS,EAAA+B,sBAAsB6E,EAAYzG,SAE7F,CAAE6O,UAASK,aAAYlX,QAAOmX,YACpC,CAAC1I,EAAaiI,EAAcC,IAEzBS,EAAgBvR,EAAM8C,YAAY,IAAM2D,EAAS,EAAAnE,cAAe,CAACmE,IAEjE+K,EAAmBxR,EAAM8C,YAAY,IAAM2D,EAAS,EAAAnE,WAAWwO,IAAiB,CAACrK,EAAUqK,IAUjG,OARA,EAAApI,WAAYvG,GAAY4O,GAAS,EAAAU,UAAUtP,EAAS4O,EAAMC,SAAU,CAAEtO,QAAS6O,IAE/E,EAAA7I,WAAYvG,GAAY4O,GAAS,EAAAU,UAAUtP,EAAS4O,EAAMM,YAAa,CAAE3O,QAAS8O,IAElF,EAAA9I,WAAYvG,GAAY4O,GAAS,EAAAU,UAAUtP,EAAS4O,EAAM5W,QAE1D,EAAAuO,WAAYvG,GAAY4O,GAAS,EAAAU,UAAUtP,EAAS4O,EAAMO,UAEnD,MAGA,EAAAV,SACT,UAAe5Q,EAAM4D,KAAKgN,I,0HCvF1B,cAgBa,EAAAK,uBAAyB,CAAC9O,EAAyBmO,KAC9D,MACM,IAAExP,GAAQqB,GACV,EAAEzB,EAAC,EAAEE,EAAC,OAAEoB,EAAM,MAAEmP,GAAUb,EAC1BnI,EAAO,EAAAM,OAAOtG,EAAQrB,IAHR,CAACpH,EAAWgY,IAAsBA,EAAY1P,EAGpBmP,GACxCpP,EAAQ,EAAAmG,aAAapH,EAAKqH,EAAMgJ,GACtC,OAAO,OAAP,wBACKb,GAAI,CACPlH,IAAK,CAAE1I,EAAGA,UAAK,EAAGE,IAAGmB,MAAOA,EAAuB,EAAfuO,EAAKY,QAAalP,OAAQA,EAAwB,EAAfsO,EAAKY,SAC5E/I,UAIS,EAAAsJ,UAA8C,CAACtP,EAAS8N,KACnE,GAAmB,MAAfA,EAAqB,OAAO,KAChC,MAAM,IAAEnP,GAAQqB,GACV,KAAEgG,EAAI,IAAEiB,EAAG,MAAE+H,EAAK,QAAED,EAAO,OAAEE,GAAWnB,EAC9CnP,EAAIoO,OACJpO,EAAI6Q,YACJ7Q,EAAIyP,KAAKnH,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QACtClB,EAAI0L,YACJ1L,EAAI8Q,OAEJ9Q,EAAIqH,KAAOA,EACXrH,EAAI6M,UAAY,OAChB7M,EAAI8M,aAAe,MACnB9M,EAAIwO,SAAS6B,EAAO/H,EAAI1I,EAAIwQ,EAAS9H,EAAIxI,EAAIsQ,GAEzCE,IACFtQ,EAAI+N,YAAc1M,EAAQT,YAAY4J,aACtCxK,EAAIgO,WAAW1F,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,SAG9ClB,EAAIyO,UAEJ,MAAMvO,EAAO,IAAIgL,OAIjB,OAHAhL,EAAKuP,KAAKnH,EAAI1I,EAAG0I,EAAIxI,EAAGwI,EAAIrH,MAAOqH,EAAIpH,QACvChB,EAAKwL,YAEE,CAAEpD,MAAKpI","file":"klondike.b377ccc3615477b6e39e.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([23,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export enum ValueType {\n  ace = 'A',\n  two = '2',\n  three = '3',\n  four = '4',\n  five = '5',\n  six = '6',\n  seven = '7',\n  eight = '8',\n  nine = '9',\n  ten = '10',\n  jack = 'J',\n  queen = 'Q',\n  king = 'K',\n}\n\nexport enum SuitType {\n  heart = '\\u2665',\n  diamond = '\\u2666',\n  spade = '\\u2660',\n  club = '\\u2663',\n}\n\nexport type Card = {\n  suit: SuitType\n  value: ValueType\n}\n\nexport type StackCard = {\n  card: Card\n  hidden?: boolean\n  selected?: boolean\n}\n\nexport enum StackDirection {\n  horizontal = 'horizontal',\n  vertical = 'vertical',\n}\n\n//\n//  1 2   3 3 3 3\n//  4 4 4 4 4 4 4\n//\n// 1 - stock\n// 2 - waste\n// 3 - foundation\n// 4 - tableau\n//\n\nexport enum StackType {\n  tableau = 'tableau',\n  foundation = 'foundation',\n  stock = 'stock',\n  waste = 'waste',\n}\n\nexport type Stack = {\n  cards: StackCard[]\n  selection: Card | null\n  type: StackType\n  direction: StackDirection | null\n  index: number\n}\n\nconst Cards: Card[] = []\n\nfor (const value of Object.values(ValueType)) {\n  for (const suit of Object.values(SuitType)) {\n    Cards.push({ suit, value })\n  }\n}\n\nObject.freeze(Cards)\n\nexport { Cards }\n","import { createSelector } from 'reselect'\nimport { StoreState } from './index'\nimport { Card, ValueType, Stack, StackType } from '../lib/Card'\nimport { isSequential, getTopCard } from '../lib/util'\n\ntype Selection = { card: Card; stack: Stack } | null\n\nexport const getAllStacks = createSelector(\n  (state: StoreState) => state.stacks.present.stacks,\n  (stacks) => stacks,\n)\n\nconst getFoundation = createSelector(getAllStacks, (stacks) =>\n  stacks.filter((stack) => stack.type === StackType.foundation),\n)\n\nexport const getGameWon = createSelector(getFoundation, (foundation) =>\n  foundation.every((stack) => stack.cards.length === 13),\n)\n\nexport const getStock = createSelector(\n  getAllStacks,\n  (stacks) => stacks.filter((stack) => stack.type === StackType.stock)[0],\n)\n\nexport const getWaste = createSelector(\n  getAllStacks,\n  (stacks) => stacks.filter((stack) => stack.type === StackType.waste)[0],\n)\n\nexport const getFoundationStack = createSelector(\n  getFoundation,\n  (_: unknown, card: Card) => card,\n  (foundation, card) =>\n    foundation.find(({ cards }) => {\n      const last = getTopCard(cards)\n      return last == null ? card.value === ValueType.ace : last.card.suit === card.suit && isSequential(card, last.card)\n    }),\n)\n\nexport const getGameState = createSelector(\n  (state: StoreState) => state.gameState.present,\n  (score) => score,\n)\n\nexport const getScore = createSelector(getGameState, (score) => score.score)\n\nexport const getScoringType = createSelector(getGameState, (score) => score.scoringType)\n\nexport const getDraws = createSelector(getGameState, ({ draws }) => draws)\n\nexport const getShowing = createSelector(getGameState, ({ showing }) => showing)\n\nexport const getSelection = createSelector(getAllStacks, (stacks) => {\n  const stack = stacks.find((stack) => stack.selection != null)\n  if (stack) return { card: stack.selection, stack: stack } as Selection\n  return null\n})\n\nexport const disallowClickStock = createSelector(\n  [getStock, getDraws],\n  (stock, draws) => stock.cards.length === 0 && draws === 0,\n)\n","import { Card, ValueType, SuitType, Stack, StackCard } from './Card'\n\n// minstd_rand\nexport const rnd = (s: number) => {\n  const rnd = () => ((2 ** 31 - 1) & (s = Math.imul(48271, s))) / 2 ** 31\n  rnd() // first call is always junk\n  return (min: number, max: number) => Math.floor(rnd() * (max - min + 1)) + min\n}\n\nexport const sumConsecutive = (i: number) => (i * (i + 1)) / 2\n\nexport const getTopCard = (cards: StackCard[]): StackCard | null => cards[cards.length - 1]\n\nexport const random = (min: number, max: number): number => Math.floor(Math.random() * max) + min\n\n// for simplicity, these routines would just use strict object comparison\n// however, if doing that, any changes to the store in a thunk would invalidate variable reference\n// this is useful for comparing a selected, or checking if stacks are the same before modifying them\n// so, we compare both value/suit when doing card comparisons, and type/index for stack comparisons\n\nexport const sameStack = (stack1: Stack, stack2: Stack) => stack1.type === stack2.type && stack1.index === stack2.index\n\nexport const sameCard = (stackCard1: StackCard, stackCard2: StackCard) =>\n  stackCard1.card.value === stackCard2.card.value && stackCard1.card.suit === stackCard2.card.suit\n\nexport const stackContainsCard = (stackCards: StackCard[], stackCard: StackCard) =>\n  stackCards.some((item: StackCard) => sameCard(item, stackCard))\n\nexport const isSequential = (card: Card, card1: Card) => valueToInt(card1.value) + 1 === valueToInt(card.value)\n\nexport const isRed = (card: Card) => [SuitType.diamond, SuitType.heart].includes(card.suit)\n\nexport const isBlack = (card: Card) => [SuitType.club, SuitType.spade].includes(card.suit)\n\nexport const isBig = (card: Card) =>\n  [ValueType.ace, ValueType.jack, ValueType.queen, ValueType.king].includes(card.value)\n\nexport const isValidMove = (card: Card, destination?: StackCard) => {\n  return destination == null\n    ? card.value === ValueType.king\n    : isSequential(destination.card, card) &&\n        ((isRed(card) && isBlack(destination.card)) || (isBlack(card) && isRed(destination.card)))\n}\n\nconst valueToInt = (value: ValueType): number => {\n  if (value === ValueType.ace) return 1\n  if (value === ValueType.jack) return 11\n  if (value === ValueType.queen) return 12\n  if (value === ValueType.king) return 13\n  return parseInt(value, 10)\n}\n","import { Reducer, AnyAction } from 'redux'\n\nexport type History<State> = {\n  past: State[]\n  present: State\n  future: State[]\n}\n\nconst DESTROY = '@@undoable/destroy'\nexport type DestroyAction = { type: typeof DESTROY }\nexport const destroy = (): DestroyAction => ({ type: DESTROY })\n\nconst UNDO = '@@undoable/undo'\ntype UndoAction = { type: typeof UNDO }\nexport const undo = (): UndoAction => ({ type: UNDO })\n\nconst REDO = '@@undoable/redo'\ntype RedoAction = { type: typeof REDO }\nexport const redo = (): RedoAction => ({ type: REDO })\n\nconst CHECKPOINT = '@@undoable/checkpoint'\ntype CheckpointAction = { type: typeof CHECKPOINT }\nexport const checkpoint = (): CheckpointAction => ({ type: CHECKPOINT })\n\nexport type UndoableActions = DestroyAction | UndoAction | RedoAction | CheckpointAction\n\nexport const undoable = <S, A extends AnyAction = UndoableActions>(reducer: Reducer<S, A>) => {\n  const initialState: History<S> = {\n    past: [],\n    present: reducer(undefined, {} as A),\n    future: [],\n  }\n\n  return (state = initialState, action: A) => {\n    const { past, present, future } = state\n\n    if (action.type === UNDO) {\n      const previous = past[past.length - 1]\n      if (!previous) {\n        return state\n      }\n\n      const newPast = past.slice(0, past.length - 1)\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future],\n      }\n    }\n\n    if (action.type === REDO) {\n      const next = future[0]\n      if (!next) {\n        return state\n      }\n\n      const newFuture = future.slice(1)\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture,\n      }\n    }\n\n    const newPresent = reducer(present, action)\n\n    if (action.type === DESTROY) {\n      return {\n        past: [],\n        present: newPresent,\n        future: [],\n      }\n    }\n\n    if (action.type === CHECKPOINT) {\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: [],\n      }\n    }\n\n    if (present === newPresent) {\n      return state\n    }\n\n    return {\n      past,\n      present: newPresent,\n      future,\n    }\n  }\n}\n","import { MOVE_CARDS } from './stacks'\nimport { StackType } from '../lib/Card'\nimport { StoreActions } from '.'\nimport { undoable } from './undoable'\nimport { INITIALIZE, InitializeAction } from './init'\n\nexport enum ScoringType {\n  vegas,\n  regular,\n}\n\nexport enum ScoreType {\n  wasteToTableau = 'wasteToTableau',\n  wasteToFoundation = 'wasteToFoundation',\n  tableauToFoundation = 'tableauToFoundation',\n  revealCard = 'revealCard',\n  foundationToTableau = 'foundationToTableau',\n}\n\nexport type GameStateStore = {\n  score: number\n  showing: number\n  draws: number\n  scoringType: ScoringType\n}\n\nconst getSavedScore = (): number => {\n  try {\n    const score = localStorage.getItem('score')\n    if (score == null) return 0\n    const parsed = parseInt(score, 10)\n    if (Number.isNaN(parsed)) return 0\n    return parsed\n  } catch (err) {\n    return 0\n  }\n}\n\nexport const saveScore = (state: GameStateStore): void => {\n  try {\n    if (state.scoringType === ScoringType.vegas) {\n      localStorage.setItem('score', state.score.toString())\n    }\n  } catch (err) {\n    // ehh, that sucks\n  }\n}\n\nconst getScoreChange = (scoringType: ScoringType, scoreType: ScoreType) => {\n  let score = 0\n  if (scoringType === ScoringType.regular && scoreType === ScoreType.tableauToFoundation) {\n    score = 10\n  } else if (\n    scoreType === ScoreType.wasteToFoundation ||\n    (scoringType === ScoringType.vegas && scoreType === ScoreType.tableauToFoundation) ||\n    (scoringType === ScoringType.regular && scoreType === ScoreType.revealCard) ||\n    (scoringType === ScoringType.regular && scoreType === ScoreType.wasteToTableau)\n  ) {\n    score = 5\n  } else if (scoringType === ScoringType.regular && ScoreType.foundationToTableau) {\n    score = -10\n  } else if (scoringType === ScoringType.vegas && scoreType === ScoreType.foundationToTableau) {\n    score = -5\n  }\n  return score\n}\n\nconst INCREMENT_SCORE = '@@game-state/increment-score'\ntype IncrementScoreAction = { type: typeof INCREMENT_SCORE; scoreType: ScoreType }\nexport const incrementScore = (scoreType: ScoreType): IncrementScoreAction => ({ type: INCREMENT_SCORE, scoreType })\n\nconst DECREMENT_DRAWS = 'DECREMENT_DRAWS'\ntype DecrementDrawsAction = { type: typeof DECREMENT_DRAWS }\nexport const decrementDraws = (): DecrementDrawsAction => ({ type: DECREMENT_DRAWS })\n\nexport type GameStateActions = DecrementDrawsAction | IncrementScoreAction | InitializeAction\n\nconst initialState: GameStateStore = {\n  showing: 0,\n  score: 0,\n  draws: Infinity,\n  scoringType: ScoringType.regular,\n}\n\nconst reducer = (state: GameStateStore = initialState, action: StoreActions): GameStateStore => {\n  if (action.type === INITIALIZE) {\n    return {\n      ...state,\n      scoringType: action.scoringType,\n      score: action.scoringType === ScoringType.vegas ? getSavedScore() - 52 : 0,\n      draws: action.scoringType === ScoringType.vegas ? 2 : Infinity,\n    }\n  }\n\n  if (action.type === DECREMENT_DRAWS) {\n    return {\n      ...state,\n      draws: state.draws - 1,\n    }\n  }\n\n  if (action.type === MOVE_CARDS) {\n    return action.to.type === StackType.waste || (action.from && action.from.type === StackType.waste)\n      ? {\n          ...state,\n          showing:\n            action.to.type === StackType.waste\n              ? Math.min(action.to.cards.length + action.cards.length, 3)\n              : Math.max(1, state.showing - 1),\n        }\n      : state\n  }\n\n  if (action.type === INCREMENT_SCORE) {\n    return {\n      ...state,\n      score: state.score + getScoreChange(state.scoringType, action.scoreType),\n    }\n  }\n  return state\n}\n\nexport default undoable(reducer)\n","import * as React from 'react'\nimport { Drawable, DrawingContext, Clickable, Handler } from '../drawing/Common'\nimport { ColorSchemeType, ColorScheme, colorSchemes } from '../drawing/ColorScheme'\nimport { initialize } from '../drawing/Common'\nimport { useCanvasSize } from '../hooks/useCanvasSize'\n\nexport type GameContext = {\n  context: DrawingContext\n  add: (thing: Drawable, events: Clickable) => void\n  remove: (path: Path2D) => void\n}\n\nexport const GameCtx = React.createContext<GameContext | null>(null)\n\nconst intersect = (evt: React.MouseEvent<HTMLCanvasElement>, pointsRef: Map<Path2D, Drawable>) => {\n  const { nativeEvent: e } = evt\n  const canvas = e.target as HTMLCanvasElement\n  const point = { x: e.offsetX, y: e.offsetY }\n  const ctx = canvas.getContext('2d')\n  for (const path of pointsRef.keys())\n    if (ctx?.isPointInPath(path, point.x, point.y)) {\n      const thing = pointsRef.get(path)\n      if (thing == null) return\n      return { thing, point }\n    }\n}\n\nconst GameCanvas: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const pointsRef = React.useRef<Map<Path2D, Drawable>>(new Map())\n  const clickHandlers = React.useRef<Map<Path2D, Handler>>(new Map())\n  const doubleClickHandlers = React.useRef<Map<Path2D, Handler>>(new Map())\n\n  const [colorScheme] = React.useState<ColorScheme>(colorSchemes[ColorSchemeType.dark])\n  const { ctx, width, height, handleCanvasRef } = useCanvasSize()\n\n  const context = React.useMemo<DrawingContext | null>(() => {\n    if (!width || !height || !ctx) return null\n    return { ctx, width, height, colorScheme }\n  }, [ctx, width, height, colorScheme])\n\n  React.useLayoutEffect(() => (context && initialize(context)) || void 0, [context])\n\n  const value = React.useMemo<GameContext | null>(\n    () =>\n      context && {\n        context,\n        add(thing, events) {\n          pointsRef.current.set(thing.path, thing)\n          if (events.onClick) clickHandlers.current.set(thing.path, events.onClick)\n          if (events.onDoubleClick) doubleClickHandlers.current.set(thing.path, events.onDoubleClick)\n        },\n        remove(path: Path2D) {\n          pointsRef.current.delete(path)\n          clickHandlers.current.delete(path)\n          doubleClickHandlers.current.delete(path)\n        },\n      },\n    [context],\n  )\n\n  const handleCanvasDoubleClick = React.useCallback((evt: React.MouseEvent<HTMLCanvasElement>) => {\n    const selection = intersect(evt, pointsRef.current)\n    if (selection) {\n      const { thing, point } = selection\n      const event = doubleClickHandlers.current.get(thing.path)\n      if (event) event(thing, point)\n    }\n  }, [])\n\n  const handleCanvasClick = React.useCallback((evt: React.MouseEvent<HTMLCanvasElement>) => {\n    const selection = intersect(evt, pointsRef.current)\n    if (selection) {\n      const { thing, point } = selection\n      const event = clickHandlers.current.get(thing.path)\n      if (event) event(thing, point)\n    }\n  }, [])\n\n  return (\n    <>\n      <canvas\n        id=\"canvas\"\n        style={{\n          backgroundColor: colorScheme.background,\n          top: '0',\n          left: '0',\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n        }}\n        ref={handleCanvasRef}\n        width={window.innerWidth}\n        height={window.innerHeight}\n        onClick={handleCanvasClick}\n        onDoubleClick={handleCanvasDoubleClick}\n      />\n      <GameCtx.Provider value={value}>{children}</GameCtx.Provider>\n    </>\n  )\n}\n\nexport { GameCanvas }\nexport default React.memo(GameCanvas)\n","import { DrawingContext, Box, Dimensions } from './Common'\nimport { Stack, StackDirection, StackType } from '../lib/Card'\n\nexport const getStackCardOffsetWidth = (ctx: DrawingContext) => Math.floor(ctx.height * 0.03)\n\nexport const getStackCardOffsetHeight = (ctx: DrawingContext) => Math.floor(ctx.height * 0.03)\n\nexport const getVerticalMarginSize = (ctx: DrawingContext) => Math.floor(ctx.height * 0.01)\n\nexport const getHorizontalMarginSize = (ctx: DrawingContext) => Math.floor(ctx.width * 0.01)\n\nexport const getTopbarBox = (): Box => ({ x: 0, y: 0, width: 0, height: 30 })\n\n// the goal is to find the highest possible card width/height satisfying the desired ratio\n// assuming a fixed top-bar height with no margin, ( it will account for its own padding )\n// and 1 vertical separator + 6 horizontal separators\n// also, need room to stack 13 stack + 6 hidden => 19 cards.\n// without exceeding the size of the window.\n\nexport const getCardDimensions = (ctx: DrawingContext): Dimensions => {\n  const horizontalMargin = getHorizontalMarginSize(ctx)\n  const verticalMargin = getVerticalMarginSize(ctx)\n  const topBarBox = getTopbarBox()\n  const stackCardOffsetHeight = getStackCardOffsetHeight(ctx)\n\n  const usedVerticalSpace = topBarBox.height + verticalMargin * 2 + stackCardOffsetHeight * 19\n  const usedHorizontalSpace = horizontalMargin * 6\n\n  const maxWidth = Math.floor((ctx.width - usedHorizontalSpace) / 7)\n  const maxHeight = Math.floor((ctx.height - usedVerticalSpace) / 1.5)\n\n  const DESIRED_RATIO = 1.618 // try to get golden ratio size cards\n  const width = maxWidth * DESIRED_RATIO < maxHeight ? maxWidth : maxHeight / DESIRED_RATIO\n  const height = maxWidth * DESIRED_RATIO < maxHeight ? maxWidth * DESIRED_RATIO : maxHeight\n\n  return {\n    width: Math.floor(width),\n    height: Math.floor(height),\n  }\n}\n\nexport const getStackBox = (ctx: DrawingContext, stack: Stack, max: number): Box => {\n  const verticalMargin = getVerticalMarginSize(ctx)\n  const horizontalMargin = getHorizontalMarginSize(ctx)\n  const topBar = getTopbarBox()\n  const { width, height } = getCardDimensions(ctx)\n  const cardLength = Math.min(stack.cards.length, max)\n\n  // we know horizontal space used\n  // it might be less than available width\n  // base x width is half that available space (for centering)\n\n  const usedWidth = horizontalMargin * 6 + width * 7\n  const baseX = usedWidth < ctx.width ? (ctx.width - usedWidth) / 2 : 0\n\n  const stackWidth =\n    stack.direction === StackDirection.horizontal\n      ? cardLength === 0\n        ? height\n        : getStackCardOffsetWidth(ctx) * (cardLength - 1) + width\n      : width\n\n  const stackHeight =\n    stack.direction === StackDirection.vertical\n      ? cardLength === 0\n        ? height\n        : getStackCardOffsetHeight(ctx) * (cardLength - 1) + height\n      : height\n\n  switch (stack.type) {\n    case StackType.stock:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX,\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.waste:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX + horizontalMargin + width,\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.foundation:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX + 3 * horizontalMargin + 3 * width + stack.index * (horizontalMargin + width),\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.tableau:\n      return {\n        y: topBar.height + verticalMargin * 3 + height,\n        x: baseX + stack.index * (horizontalMargin + width),\n        width: stackWidth,\n        height: stackHeight,\n      }\n  }\n}\n","import { Stack, StackCard, StackType, Card, StackDirection } from '../lib/Card'\nimport { stackContainsCard, sumConsecutive, sameStack, sameCard } from '../lib/util'\nimport { undoable } from './undoable'\nimport { INITIALIZE, InitializeAction } from './init'\n\nexport const SELECT = '@@global/select-card'\nexport type SelectAction = { type: typeof SELECT; stack: Stack; card: StackCard }\nexport const selectCard = (stack: Stack, card: StackCard): SelectAction => ({ type: SELECT, card, stack })\n\nexport const DESELECT = '@@global/deselect-card'\nexport type DeselectAction = { type: typeof DESELECT }\nexport const deselectCard = (): DeselectAction => ({ type: DESELECT })\n\nexport const REVEAL_TOP = '@@global/reveal-top'\nexport type RevealTopCardAction = { type: typeof REVEAL_TOP; stack: Stack }\nexport const reveal = (stack: Stack): RevealTopCardAction => ({ type: REVEAL_TOP, stack })\n\nexport const MOVE_CARDS = '@@global/move-cards'\nexport type MoveCardAction = { type: typeof MOVE_CARDS; from?: Stack; to: Stack; cards: StackCard[]; hidden: boolean }\n\n// move 3 cards from the stock to the waste\nexport const throwStock = (stock: Stack, waste: Stack): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from: stock,\n  to: waste,\n  cards: stock.cards.slice(-3).reverse(),\n  hidden: false,\n})\n\n// move all cards from waste back to the stock\nexport const recycleWaste = (waste: Stack, stock: Stack): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from: waste,\n  to: stock,\n  cards: waste.cards.slice(0),\n  hidden: true,\n})\n\n// other general moves\nexport const moveCards = (from: Stack, to: Stack, from_card: Card | null = null): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from,\n  to,\n  cards: from.cards.slice(from.cards.findIndex((card) => card.card === from_card)),\n  hidden: false,\n})\n\nexport type CardActions = SelectAction | DeselectAction | RevealTopCardAction | MoveCardAction\n\nconst reducers: {\n  [key: string]: (state: StackStore, action: CardActions | InitializeAction) => StackStore\n} = {\n  [INITIALIZE]: (state, action: InitializeAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) => {\n      if (stack.type === StackType.foundation || stack.type === StackType.waste) {\n        return { ...stack, cards: [] }\n      }\n      if (stack.type === StackType.stock) {\n        return { ...stack, cards: action.cards.slice(0, 24).map((card) => ({ card, hidden: true })) }\n      }\n      if (stack.type === StackType.tableau) {\n        return {\n          ...stack,\n          cards: action.cards\n            .slice(24 + sumConsecutive(stack.index), 24 + sumConsecutive(stack.index) + stack.index + 1)\n            .map((card, index, a) => ({ card, hidden: a.length !== index + 1 })),\n        }\n      }\n      return stack\n    }),\n  }),\n  [SELECT]: (state, action: SelectAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      sameStack(stack, action.stack) && stackContainsCard(stack.cards, action.card)\n        ? {\n            ...stack,\n            selection: action.card.card,\n            cards: stack.cards.map((stackCard) =>\n              !sameCard(stackCard, action.card) ? stackCard : { ...stackCard, selected: true },\n            ),\n          }\n        : stack,\n    ),\n  }),\n  [DESELECT]: (state) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      stack.selection != null\n        ? {\n            ...stack,\n            selection: null,\n            cards: stack.cards.map((stackCard) =>\n              !stackCard.selected ? stackCard : { ...stackCard, selected: false },\n            ),\n          }\n        : stack,\n    ),\n  }),\n  [MOVE_CARDS]: (state, action: MoveCardAction) =>\n    state.stacks.some((stack) => [action.from, action.to].includes(stack))\n      ? {\n          ...state,\n          stacks: state.stacks.map((stack) =>\n            sameStack(stack, action.to)\n              ? {\n                  ...stack,\n                  cards: [\n                    ...stack.cards,\n                    ...action.cards.map((card) => ({ ...card, selected: false, hidden: action.hidden })),\n                  ],\n                }\n              : action.from && sameStack(stack, action.from)\n              ? {\n                  ...stack,\n                  cards: stack.cards.filter((stackCard) => !stackContainsCard(action.cards, stackCard)),\n                }\n              : stack,\n          ),\n        }\n      : state,\n  [REVEAL_TOP]: (state, action: RevealTopCardAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      sameStack(stack, action.stack)\n        ? {\n            ...stack,\n            cards: stack.cards.map((card, index) =>\n              index < stack.cards.length - 1 ? card : { ...card, hidden: false },\n            ),\n          }\n        : stack,\n    ),\n  }),\n}\n\nexport type StackStore = {\n  readonly stacks: Stack[]\n}\n\nconst initialState: StackStore = {\n  stacks: [\n    {\n      type: StackType.stock,\n      direction: null,\n      cards: [],\n      index: 0,\n      selection: null,\n    },\n    {\n      type: StackType.waste,\n      direction: StackDirection.horizontal,\n      cards: [],\n      index: 0,\n      selection: null,\n    },\n    ...Array.from<number, Stack>({ length: 7 }, (_, index) => ({\n      index,\n      type: StackType.tableau,\n      direction: StackDirection.vertical,\n      cards: [],\n      selection: null,\n    })),\n    ...Array.from<number, Stack>({ length: 4 }, (_, index) => ({\n      index,\n      type: StackType.foundation,\n      direction: null,\n      cards: [],\n      selection: null,\n    })),\n  ],\n}\n\nconst reducer = (state: StackStore = initialState, action: CardActions): StackStore => {\n  const r = reducers[action.type]\n  if (r) return r(state, action)\n  return state\n}\n\nexport default undoable(reducer)\n","import { ScoringType } from './game-state'\nimport { Card } from '../lib/Card'\n\n// this is in it's own file because circular dependencies are jerks.\n\nexport const INITIALIZE = '@@game-state/initialize'\nexport type InitializeAction = { type: typeof INITIALIZE; scoringType: ScoringType; cards: Card[] }\nexport const initialize = (scoringType: ScoringType, cards: Card[]): InitializeAction => ({\n  type: INITIALIZE,\n  scoringType,\n  cards,\n})\n","import { ThunkAction, ThunkDispatch as ReduxThunkDispatch } from 'redux-thunk'\n\nimport { StoreState, StoreActions } from '.'\nimport { isValidMove, random } from '../lib/util'\nimport { Stack, StackCard, StackType, Card, Cards } from '../lib/Card'\n\nimport { moveCards, deselectCard, selectCard, reveal, throwStock, recycleWaste } from './stacks'\nimport { getSelection, getFoundationStack, disallowClickStock, getWaste, getStock, getScoringType } from './selectors'\nimport { checkpoint } from './undoable'\nimport { incrementScore, ScoreType, ScoringType, decrementDraws } from './game-state'\nimport { initialize as initializeGame } from './init'\n\nexport type ThunkResult<R, E = null> = ThunkAction<R, StoreState, E, StoreActions>\nexport type ThunkDispatch<E = null> = ReduxThunkDispatch<StoreState, E, StoreActions>\n\ninterface CardClickAction<T = void> {\n  (stack: Stack, stackCard?: StackCard): ThunkResult<T>\n}\n\nexport const initialize = (newScoringType?: ScoringType): ThunkResult<void> => (dispatch, getState) => {\n  const scoringType = newScoringType == null ? getScoringType(getState()) : newScoringType\n  const availableCards = Array.from(Cards)\n  const cards: Card[] = []\n\n  for (let i = 0; i < 52; i++) {\n    const index = random(0, availableCards.length)\n    cards.push(...availableCards.splice(index, 1))\n  }\n\n  dispatch(initializeGame(scoringType, cards))\n}\n\nexport const clickCard: CardClickAction = (clickedStack, clickedCard) => (dispatch, getState) => {\n  if (clickedCard != null && clickedCard.selected) return dispatch(deselectCard())\n\n  const selection = getSelection(getState())\n  if (selection == null && clickedCard && !clickedCard.hidden) return dispatch(selectCard(clickedStack, clickedCard))\n\n  if (clickedStack.type === StackType.foundation) {\n    const foundation = (selection && getFoundationStack(getState(), selection.card)) || null\n    if (foundation && selection) {\n      dispatch(deselectCard())\n      dispatch(checkpoint())\n      if (selection.stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToFoundation))\n      if (selection.stack.type === StackType.tableau) dispatch(incrementScore(ScoreType.tableauToFoundation))\n      dispatch(moveCards(selection.stack, foundation, selection.card))\n    }\n    return\n  }\n\n  if (clickedStack.type === StackType.tableau) {\n    if (selection == null && clickedCard && clickedCard.hidden) {\n      dispatch(checkpoint())\n      dispatch(incrementScore(ScoreType.revealCard))\n      dispatch(reveal(clickedStack))\n    }\n    if (selection != null && isValidMove(selection.card, clickedCard)) {\n      dispatch(deselectCard())\n      dispatch(checkpoint())\n      if (selection.stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToTableau))\n      if (selection.stack.type === StackType.foundation) dispatch(incrementScore(ScoreType.foundationToTableau))\n      dispatch(moveCards(selection.stack, clickedStack, selection.card))\n    }\n  }\n\n  if (clickedStack.type === StackType.stock) {\n    if (disallowClickStock(getState())) return\n    if (selection) dispatch(deselectCard())\n    const waste = getWaste(getState())\n    const stock = getStock(getState())\n    dispatch(checkpoint())\n    if (stock.cards.length > 0) {\n      dispatch(throwStock(stock, waste))\n    } else {\n      dispatch(recycleWaste(waste, stock))\n      dispatch(decrementDraws())\n    }\n  }\n}\n\nexport const doubleClickCard: CardClickAction = (stack, stackCard) => (dispatch, getState) => {\n  if (\n    stack.type === StackType.foundation ||\n    stack.type === StackType.stock ||\n    stackCard == null ||\n    stackCard.card == null\n  ) {\n    return\n  }\n\n  const foundation = getFoundationStack(getState(), stackCard.card)\n  if (!foundation) return\n\n  dispatch(checkpoint())\n  if (stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToFoundation))\n  if (stack.type === StackType.tableau) dispatch(incrementScore(ScoreType.tableauToFoundation))\n  dispatch(moveCards(stack, foundation, stackCard.card))\n  dispatch(deselectCard())\n}\n","import { Cards, StackCard } from '../lib/Card'\nimport { ColorScheme } from './ColorScheme'\nimport { getErrorImageData, getEmptyImageData, getHiddenImageData, getCardImageData } from './Card'\nimport { getCardDimensions } from './Layout'\n\n// this is passed to all drawing routines. it includes :\n// the color they should draw,\n// the ctx to draw it on, and\n// the width/height of the canvas.\n\nexport type DrawingContext = { ctx: CanvasRenderingContext2D; colorScheme: ColorScheme } & Dimensions\n\nexport type Dimensions = { width: number; height: number }\n\nexport type Point = { x: number; y: number }\n\nexport type Box = Dimensions & Point\n\n// something that is drawable includes an x/y coords and a height/width\n// once removed, clearRect is with these values to clean it from the canvas\n// also, the click/double click handlers will inspect if point is in their path.\n\nexport type Drawable = { path: Path2D; box: Box }\n\n// a draw routine takes drawing context above, and include whatever options they want\n// they perform mutations to the cavas (draw the thing) and return a drawable for tracking (above)\n\nexport interface DrawRoutine<DrawingOpts> {\n  (context: DrawingContext, arg1: DrawingOpts | null): Drawable | null\n}\n\nexport interface Handler {\n  (arg0: Drawable, arg1: Point): void\n}\n\nexport type Clickable = { onClick?: Handler; onDoubleClick?: Handler }\n\n// a cache of cards is kept and re-initialized when color scheme / window dimensions change\n// this is a map of a key identifying the stack card, and the raw pixel data to draw it.\n// the idea is this is all cached one time at the beginning and re-used\n\n// this uses a string with keys because it's actually a \"StackCard\" we're interested in\n// this includes the selected flag - the highlighted / non-highlighted state need to both be kept\n// while `Cards` is immutable singleton of all available cads, StackCards is not and\n// using a non-string key, we'll wind up with missing references not hitting the cache.\n\nexport const getKey = ({ card: { suit, value }, selected }: StackCard) =>\n  `${suit}_${value}_${(selected || false).toString()}`\n\nexport const cardCache: Map<string, ImageData> = new Map()\n\nlet c2: HTMLCanvasElement\n\nexport const initialize = (context: DrawingContext) => {\n  const { width, height } = getCardDimensions(context)\n  cardCache.set('hidden', getHiddenImageData(context))\n  cardCache.set('empty', getEmptyImageData(context))\n  cardCache.set('error', getErrorImageData(context))\n  Cards.forEach((card) => {\n    cardCache\n      .set(getKey({ card, selected: true }), getCardImageData(context, { card, selected: true }))\n      .set(getKey({ card, selected: false }), getCardImageData(context, { card, selected: false }))\n  })\n\n  c2 = document.createElement('canvas')\n  c2.width = width\n  c2.height = height\n  context.ctx.clearRect(0, 0, width + 2, height + 2)\n}\n\n// to get transarency working, (maybe other composition?) need an intermediary canvas to proxy the drawing.\n\nexport const writeDataToCanvas = (context: DrawingContext, data: ImageData, x: number, y: number) => {\n  const ctx2 = c2.getContext('2d')\n  ctx2?.putImageData(data, 0, 0)\n  context.ctx.drawImage(c2, x, y)\n}\n","const allFontSizes = Array.from<number, number>({ length: 200 }, (v, k) => k)\n\ninterface isBigEnough {\n  (width: number, height: number): boolean\n}\n\nexport const measureWidth = (ctx: CanvasRenderingContext2D, font: string, text: string) => {\n  ctx.font = font\n  return ctx.measureText(text).width\n}\n\nexport const measureHeight = (ctx: CanvasRenderingContext2D, font: string) => {\n  ctx.font = font\n  return ctx.measureText('M').width // close enough\n}\n\nconst searchFontSize = (\n  ctx: CanvasRenderingContext2D,\n  isBigEnough: isBigEnough,\n  text: string,\n  min: number,\n  max: number,\n): string => {\n  const index = Math.floor((max + min) / 2)\n  const font = `${allFontSizes[index]}px sans-serif`\n  const width = measureWidth(ctx, font, text)\n  const height = measureHeight(ctx, font)\n  if (min > max) return font\n  if (isBigEnough(width, height)) return searchFontSize(ctx, isBigEnough, text, min, index - 1)\n  return searchFontSize(ctx, isBigEnough, text, index + 1, max)\n}\n\nexport const search = (ctx: CanvasRenderingContext2D, isBigEnough: isBigEnough, text: string) =>\n  searchFontSize(ctx, isBigEnough, text, 0, allFontSizes.length - 1)\n","import * as React from 'react'\nimport { GameCtx } from '../components/GameCanvas'\nimport { Clickable, DrawingContext, Drawable } from '../drawing/Common'\n\nexport interface Drawer {\n  (context: DrawingContext): Drawable | null\n}\n\nexport const useDrawing = (draw: Drawer, events: Clickable = {}) => {\n  const gameContext = React.useContext(GameCtx)\n  const performCleanup = React.useRef(true)\n  const lastWidth = React.useRef(gameContext?.context.width ?? 0)\n  const lastHeight = React.useRef(gameContext?.context.height ?? 0)\n\n  // should only clear the rects if we haven't just resized the screen\n  // a screen resize will already clear the entire canvas\n  // if this isn't tracked, we end up drawing a new game and clear out the old sizes, leaving blank holes.\n\n  React.useEffect(() => {\n    if (!gameContext) return\n    performCleanup.current = !(\n      (lastHeight.current !== gameContext.context.height || lastWidth.current !== gameContext.context.width) &&\n      lastHeight.current > 0 &&\n      lastWidth.current > 0\n    )\n  }, [gameContext])\n\n  React.useEffect(() => {\n    if (gameContext == null) return\n    const { add, remove, context } = gameContext\n    const { ctx } = context\n\n    const thing = draw(context)\n    if (thing == null) return\n    add(thing, events)\n\n    return () => {\n      remove(thing.path)\n      if (performCleanup.current) {\n        ctx.clearRect(thing.box.x, thing.box.y, thing.box.width, thing.box.height)\n      }\n      performCleanup.current = true\n    }\n  })\n}\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport * as offline from 'offline-plugin/runtime'\n\nimport App from './components/App'\n\nconst NODE_ENV = process.env.NODE_ENV\nif (NODE_ENV === 'production') {\n  offline.install({\n    onUpdateReady() {\n      offline.applyUpdate()\n    },\n    onUpdated() {\n      window.location.reload()\n    },\n  })\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n","import * as React from 'react'\n\nimport { Provider } from 'react-redux'\n\nimport configStore from '../store'\nimport { ThunkDispatch, initialize } from '../redux/thunks'\nimport Container from './Container'\n\nconst App: React.FC = () => {\n  const store = configStore()\n  const dispatch = store.dispatch as ThunkDispatch\n\n  dispatch(initialize())\n\n  return (\n    <Provider store={store}>\n      <Container />\n    </Provider>\n  )\n}\n\nexport { App }\n\nexport default React.memo(App)\n","import { createStore, applyMiddleware } from 'redux'\nimport thunk, { ThunkMiddleware } from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport reducer, { StoreState, StoreActions } from './redux'\nimport subscribe from 'redux-subscribe-reselect'\nimport { saveScore, GameStateStore } from './redux/game-state'\nimport { getGameState } from './redux/selectors'\n\nexport default () => {\n  const middleware = []\n\n  middleware.push(thunk as ThunkMiddleware<StoreState, StoreActions>)\n\n  if (process.env.NODE_ENV !== 'production') {\n    middleware.push(\n      createLogger({\n        stateTransformer: (state: StoreState) => ({\n          gameState: state.gameState.present,\n          stacks: state.stacks.present,\n        }),\n      }),\n    )\n  }\n\n  const store = createStore(reducer, void 0, applyMiddleware(...middleware))\n  subscribe(store, getGameState, (score: GameStateStore) => saveScore(score))\n  return store\n}\n","import { combineReducers } from 'redux'\nimport stacks, { CardActions, StackStore } from './stacks'\nimport gameState, { GameStateActions, GameStateStore } from './game-state'\nimport { History, UndoableActions } from './undoable'\n\nexport type StoreActions = GameStateActions | CardActions | UndoableActions\n\nexport type StoreState = {\n  stacks: History<StackStore>\n  gameState: History<GameStateStore>\n}\n\nexport default combineReducers<StoreState, StoreActions>({ stacks, gameState })\n","import * as React from 'react'\nimport { hot } from 'react-hot-loader/root'\nimport { useDispatch, useSelector } from 'react-redux'\nimport FireworksComponent from './Fireworks'\nimport { undo, redo } from '../redux/undoable'\nimport GameCanvas from './GameCanvas'\nimport StackElement from './StackElement'\n\nimport { getDraws, getShowing, getAllStacks } from '../redux/selectors'\nimport TopBar from './TopBar'\n\nconst Container: React.FC = () => {\n  const dispatch = useDispatch()\n  const stacks = useSelector(getAllStacks)\n  const draws = useSelector(getDraws)\n  const showing = useSelector(getShowing)\n\n  React.useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.keyCode !== 90) return\n      if (e.ctrlKey && e.shiftKey) {\n        dispatch(redo())\n      } else if (e.ctrlKey) {\n        dispatch(undo())\n      }\n    }\n    document.addEventListener('keydown', handler)\n    return () => document.removeEventListener('keydown', handler)\n  }, [dispatch])\n\n  return (\n    <div>\n      <FireworksComponent />\n      <GameCanvas>\n        <TopBar />\n        {stacks.map((stack) => (\n          <StackElement key={`${stack.type}-${stack.index}`} stack={stack} showing={showing} draws={draws} />\n        ))}\n      </GameCanvas>\n    </div>\n  )\n}\n\nexport default hot(React.memo(Container))\n","import * as React from 'react'\nimport { useSelector } from 'react-redux'\nimport * as FireworksCanvas from 'fireworks-canvas'\nimport { getGameWon } from '../redux/selectors'\n\nconst Fireworks: React.FC = () => {\n  const ref = React.useRef<HTMLDivElement>(null)\n  const fireworksObj = React.useRef<FireworksCanvas>()\n  const active = useSelector(getGameWon)\n  const display = active ? '' : 'none'\n\n  React.useEffect(() => {\n    if (ref.current == null) return\n    fireworksObj.current = new FireworksCanvas(ref.current)\n\n    const handleDocumentKeyDown = (ev: KeyboardEvent) => {\n      if (ev.keyCode === 27) fireworksObj.current?.stop()\n    }\n\n    document.addEventListener('keydown', handleDocumentKeyDown)\n\n    return () => {\n      fireworksObj.current?.destroy()\n    }\n  }, [ref, active])\n\n  React.useEffect(() => {\n    if (active) {\n      fireworksObj.current?.stop()\n    } else {\n      fireworksObj.current?.start()\n    }\n  }, [active])\n\n  return (\n    <div\n      style={{\n        display,\n        top: '0',\n        left: '0',\n        width: '100vw',\n        height: '100vh',\n        position: 'absolute',\n      }}\n      ref={ref}\n    />\n  )\n}\n\nexport default React.memo(Fireworks)\n","export enum ColorSchemeType {\n  dark,\n  light,\n}\n\nexport type ColorScheme = {\n  background: string\n  faceDown: string\n  buttonBorder: string\n  cardBorder: string\n  faceUp: string\n  selected: string\n  red: string\n  black: string\n  emptyColor: string\n  errorColor: string\n}\n\nexport const colorSchemes: { [key in ColorSchemeType]: ColorScheme } = {\n  [ColorSchemeType.dark]: {\n    background: '#000',\n    emptyColor: '#060606',\n    faceUp: '#222',\n    faceDown: '#333',\n    buttonBorder: '#ddd',\n    cardBorder: '#000',\n    black: '#999',\n    red: '#900',\n    selected: '#660',\n    errorColor: '#900',\n  },\n  [ColorSchemeType.light]: {\n    background: '#fff',\n    emptyColor: '#eee',\n    faceUp: '#ddd',\n    faceDown: '#ccc',\n    buttonBorder: '#000',\n    cardBorder: '#333',\n    black: '#333',\n    red: 'crimson',\n    selected: 'yellow',\n    errorColor: 'red',\n  },\n}\n","import { ValueType, SuitType, StackCard } from '../lib/Card'\nimport { Box, DrawingContext } from './Common'\nimport { isBig, isRed } from '../lib/util'\nimport { search, measureHeight } from './FontSize'\n\nimport { getCardDimensions, getVerticalMarginSize, getHorizontalMarginSize } from './Layout'\n\ntype Glyph = {\n  glyph: ValueType | SuitType\n  x: number\n  y: number\n  rotated: boolean\n  textAlign: CanvasTextAlign\n  textBaseline: CanvasTextBaseline\n  font: string\n}\n\ninterface GetCard {\n  (context: DrawingContext, card?: StackCard): ImageData\n}\n\nexport const getBoxPath = ({ x, y, width, height }: Box, radius = 10, smaller = 0) => {\n  const path = new Path2D()\n\n  const dx = x + smaller\n  const dy = y + smaller\n  const dw = width - smaller * 2\n  const dh = height - smaller * 2\n\n  path.moveTo(dx + radius, dy)\n  path.lineTo(dx + dw - radius, dy)\n  path.quadraticCurveTo(dx + dw, dy, dx + dw, dy + radius)\n  path.lineTo(dx + dw, dy + dh - radius)\n  path.quadraticCurveTo(dx + dw, dy + dh, dx + dw - radius, dy + dh)\n  path.lineTo(dx + radius, dy + dh)\n  path.quadraticCurveTo(dx, dy + dh, dx, dy + dh - radius)\n  path.lineTo(dx, dy + radius)\n  path.quadraticCurveTo(dx, dy, dx + radius, dy)\n  path.closePath()\n  return path\n}\n\nenum FontSizeType {\n  Regular,\n  Corner,\n}\n\nexport const getGlyphLocations = (context: DrawingContext, { card, hidden }: StackCard): Glyph[] => {\n  if (hidden) return []\n\n  const { ctx } = context\n  const { width: cardWidth, height: cardHeight } = getCardDimensions(context)\n  const gutterHeight = getVerticalMarginSize(context)\n  const gutterWidth = getHorizontalMarginSize(context)\n\n  const cornerWidth = Math.floor(cardWidth * 0.2)\n  const figureOutFontSize = (type: FontSizeType) =>\n    search(\n      ctx,\n      (width: number, height: number) =>\n        type === FontSizeType.Corner\n          ? width > cornerWidth\n          : isBig(card)\n          ? width > cardWidth - Math.floor(cardWidth / 5) * 2\n          : width > Math.floor(cardWidth / 5) && height > Math.floor(cardHeight / 20),\n      type === FontSizeType.Corner ? '10' : '\\u2665',\n    )\n\n  const fontSizes: { [key in FontSizeType]: string } = {\n    [FontSizeType.Corner]: figureOutFontSize(FontSizeType.Corner),\n    [FontSizeType.Regular]: figureOutFontSize(FontSizeType.Regular),\n  }\n\n  // 20% of width is reserved for corner pieces\n  // y of suit is margin + height of value + margin\n  const cornerHeight = measureHeight(ctx, fontSizes[FontSizeType.Corner])\n\n  const cornerValueX = gutterWidth / 2\n  const cornerValueY = gutterHeight / 2\n  const cornerSuitX = gutterWidth / 2\n  const cornerSuitY = gutterWidth / 2 + cornerHeight\n\n  const { suit, value } = card\n\n  // top-left, bottom-right glyphs\n  const positions = [\n    { x: cornerValueX, y: cornerValueY, glyph: value },\n    { x: cornerSuitX, y: cornerSuitY, glyph: suit },\n  ].reduce((memo, glyph) => {\n    memo.push(\n      {\n        ...glyph,\n        rotated: false,\n        textAlign: 'left',\n        textBaseline: 'top',\n        font: fontSizes[FontSizeType.Corner],\n      },\n      {\n        ...glyph,\n        rotated: true,\n        textAlign: 'left',\n        textBaseline: 'top',\n        font: fontSizes[FontSizeType.Corner],\n      },\n    )\n    return memo\n  }, [] as Glyph[])\n\n  type ypos = 0 | 1 | 2 | 3 | 4 | 5 | 6\n\n  type xpos = 0 | 1 | 2\n\n  const pos: { x: xpos; y: ypos }[] = []\n\n  if (\n    [\n      ValueType.ace,\n      ValueType.three,\n      ValueType.five,\n      ValueType.nine,\n      ValueType.jack,\n      ValueType.queen,\n      ValueType.king,\n    ].includes(value)\n  ) {\n    pos.push({ x: 1, y: 3 })\n  }\n\n  if ([ValueType.two, ValueType.three].includes(value)) {\n    pos.push({ x: 1, y: 0 }, { x: 1, y: 6 })\n  }\n\n  if (\n    [\n      ValueType.four,\n      ValueType.five,\n      ValueType.six,\n      ValueType.seven,\n      ValueType.eight,\n      ValueType.nine,\n      ValueType.ten,\n    ].includes(value)\n  ) {\n    pos.push({ x: 0, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 6 }, { x: 2, y: 6 })\n  }\n\n  if ([ValueType.six, ValueType.seven, ValueType.eight].includes(value)) {\n    pos.push({ x: 0, y: 3 }, { x: 2, y: 3 })\n  }\n\n  if ([ValueType.seven, ValueType.ten, ValueType.eight].includes(value)) {\n    pos.push({ x: 1, y: 1 })\n  }\n\n  if ([ValueType.nine, ValueType.ten].includes(value)) {\n    pos.push({ x: 0, y: 2 }, { x: 2, y: 2 }, { x: 0, y: 4 }, { x: 2, y: 4 })\n  }\n\n  if ([ValueType.ten, ValueType.eight].includes(value)) {\n    pos.push({ x: 1, y: 5 })\n  }\n\n  const getTop = (y: ypos) => {\n    switch (y) {\n      case 0:\n      case 6:\n        return cardHeight * 0.2\n      case 1:\n      case 5:\n        return cardHeight * 0.3\n      case 2:\n      case 4:\n        return cardHeight * 0.4\n      case 3:\n        return cardHeight * 0.5\n    }\n  }\n\n  const getLeft = (x: xpos) => {\n    switch (x) {\n      case 0:\n        return cardWidth * 0.25\n      case 1:\n        return cardWidth * 0.5\n      case 2:\n        return cardWidth * 0.75\n    }\n  }\n\n  const getTextAlign = (x: xpos): CanvasTextAlign => {\n    switch (x) {\n      case 0:\n        return 'left'\n      case 1:\n        return 'center'\n      case 2:\n        return 'right'\n    }\n  }\n\n  pos.forEach(({ x, y }) => {\n    positions.push({\n      x: getLeft(x),\n      y: getTop(y),\n      glyph: suit,\n      textAlign: getTextAlign(x),\n      textBaseline: 'middle',\n      rotated: y > 3,\n      font: fontSizes[FontSizeType.Regular],\n    })\n  })\n\n  return positions\n}\n\nexport const getEmptyImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(0, 0, width, height)\n  ctx.fillStyle = colorScheme.emptyColor\n  ctx.fillRect(box.x, box.y, box.width, box.height)\n  ctx.lineWidth = 0.5\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.strokeRect(box.x, box.y, box.width, box.height)\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getHiddenImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.lineWidth = 2\n  ctx.stroke(getBoxPath(box, 10))\n  ctx.fillStyle = colorScheme.faceDown\n  ctx.fill(getBoxPath(box, 10, 0.5))\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getCardImageData: GetCard = (context: DrawingContext, card: StackCard) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.lineWidth = 2\n  ctx.stroke(getBoxPath(box, 10))\n\n  ctx.fillStyle = card.selected ? colorScheme.selected : colorScheme.faceUp\n  ctx.fill(getBoxPath(box, 10, 0.5))\n\n  for (const glyph of getGlyphLocations(context, card)) {\n    ctx.fillStyle = isRed(card.card) ? colorScheme.red : colorScheme.black\n    ctx.textAlign = glyph.textAlign\n    ctx.textBaseline = glyph.textBaseline\n    ctx.font = glyph.font\n    if (glyph.rotated) {\n      ctx.save()\n      ctx.translate(width, height)\n      ctx.rotate(Math.PI)\n    }\n    ctx.fillText(glyph.glyph, glyph.x + box.x * (glyph.rotated ? -1 : 1), glyph.y + box.y * (glyph.rotated ? -1 : 1))\n    if (glyph.rotated) ctx.restore()\n  }\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getErrorImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.fillStyle = colorScheme.emptyColor\n  ctx.fill(getBoxPath(box))\n  ctx.font = '48px sans-serif'\n  ctx.textAlign = 'center'\n  ctx.textBaseline = 'middle'\n  ctx.fillStyle = colorScheme.errorColor\n  ctx.fillText('X', box.width / 2, box.height / 2)\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n","import * as React from 'react'\nimport { Dimensions } from '../drawing/Common'\n\ntype CanvasSizeReturn = {\n  ctx?: CanvasRenderingContext2D\n  width?: number\n  height?: number\n  handleCanvasRef: (canvas: HTMLCanvasElement) => void\n}\n\nexport const useCanvasSize = (): CanvasSizeReturn => {\n  const [canvas, setCanvas] = React.useState<HTMLCanvasElement | null>(null)\n  const handleCanvasRef = React.useCallback((canvas: HTMLCanvasElement) => canvas && setCanvas(canvas), [])\n\n  const getSize = () => ({ width: window.innerWidth, height: window.innerHeight })\n\n  const [size, setSize] = React.useState<Dimensions>()\n\n  React.useEffect(() => {\n    if (!canvas) return\n    const ctx = canvas.getContext('2d')\n    if (ctx == null) return\n    let tid: number\n    const handleSize = () => {\n      if (tid) clearTimeout(tid)\n      tid = window.setTimeout(() => setSize(getSize()), 300)\n    }\n    window.addEventListener('resize', handleSize)\n    return () => {\n      window.removeEventListener('resize', handleSize)\n    }\n  })\n\n  const retVal = React.useMemo(\n    () => ({\n      handleCanvasRef,\n      ...(canvas && {\n        ctx: canvas.getContext('2d') as CanvasRenderingContext2D,\n        ...(size ?? getSize()),\n      }),\n    }),\n    [size, handleCanvasRef, canvas],\n  )\n\n  return retVal\n}\n","import * as React from 'react'\nimport { GameCtx } from './GameCanvas'\nimport { drawStack, StackDrawingContext, getStackDrawingContext } from '../drawing/Stack'\nimport { Stack, StackDirection, StackType } from '../lib/Card'\nimport { useDispatch } from 'react-redux'\nimport { clickCard, doubleClickCard } from '../redux/thunks'\nimport { Point, Drawable } from '../drawing/Common'\nimport { useDrawing } from '../hooks/useDrawing'\nimport { useMemo } from 'react'\n\nconst StackElement: React.FC<{\n  stack: Stack\n  draws: number\n  showing: number\n}> = ({ stack, draws, showing }) => {\n  const dispatch = useDispatch()\n  const gameContext = React.useContext(GameCtx)\n\n  const drawingOpts = useMemo<StackDrawingContext | null>(\n    () => gameContext && getStackDrawingContext(gameContext.context, stack, { draws, showing }),\n    [gameContext, stack, draws, showing],\n  )\n\n  const onDoubleClick = React.useCallback(\n    (thing: Drawable, point: Point) => {\n      if (gameContext == null || drawingOpts == null) return\n      const prop = stack.direction === StackDirection.horizontal ? 'x' : 'y'\n      const cards = stack.cards.slice(-drawingOpts.max)\n      const index = Math.min(cards.length - 1, Math.floor((point[prop] - drawingOpts.box[prop]) / drawingOpts.space))\n      if (stack.type !== StackType.waste || index === cards.length - 1) dispatch(doubleClickCard(stack, cards[index]))\n    },\n    [dispatch, gameContext, drawingOpts, stack],\n  )\n\n  const onClick = React.useCallback(\n    (thing: Drawable, point: Point) => {\n      if (gameContext == null || drawingOpts == null) return\n      const prop = stack.direction === StackDirection.horizontal ? 'x' : 'y'\n      const cards = stack.cards.slice(-drawingOpts.max)\n      const index = Math.min(cards.length - 1, Math.floor((point[prop] - drawingOpts.box[prop]) / drawingOpts.space))\n      if (stack.type !== StackType.waste || index === cards.length - 1) dispatch(clickCard(stack, cards[index]))\n    },\n    [dispatch, gameContext, drawingOpts, stack],\n  )\n\n  useDrawing((context) => drawStack(context, drawingOpts), { onClick, onDoubleClick })\n\n  return null\n}\n\nexport { StackElement }\nexport default React.memo(StackElement)\n","import { Stack, StackDirection, StackType } from '../lib/Card'\nimport { writeDataToCanvas, cardCache, getKey, DrawingContext, DrawRoutine, Box } from './Common'\nimport { getStackCardOffsetWidth, getStackCardOffsetHeight, getStackBox } from './Layout'\n\nexport type StackDrawingOptions = {\n  draws: number\n  showing: number\n}\n\nexport type StackDrawingContext = StackDrawingOptions & {\n  stack: Stack\n  space: number\n  max: number\n  box: Box\n}\n\nexport const getStackDrawingContext = (\n  context: DrawingContext,\n  stack: Stack,\n  opts: StackDrawingOptions,\n): StackDrawingContext => {\n  const max =\n    stack.type === StackType.stock || stack.type === StackType.foundation\n      ? 1\n      : stack.type === StackType.waste\n      ? opts.showing || 0\n      : stack.cards.length\n\n  const box = getStackBox(context, stack, max)\n\n  const space =\n    stack.direction === StackDirection.horizontal ? getStackCardOffsetWidth(context) : getStackCardOffsetHeight(context)\n\n  return {\n    stack,\n    draws: opts.draws,\n    showing: opts.showing,\n    space,\n    box,\n    max,\n  }\n}\n\nexport const drawStack: DrawRoutine<StackDrawingContext> = (context, drawingOpts) => {\n  if (drawingOpts == null) return null\n  const { stack, draws, max, space, box } = drawingOpts\n  const cards = stack.cards.slice(-max)\n\n  const path = new Path2D()\n  path.rect(box.x, box.y, box.width, box.height)\n  path.closePath()\n\n  const empty = cards.length === 0\n  const error = stack.type === StackType.stock && empty && draws === 0\n  const elements = []\n\n  if (error) elements.push({ data: cardCache.get('error'), x: box.x, y: box.y })\n  else if (empty) elements.push({ data: cardCache.get('empty'), x: box.x, y: box.y })\n  else\n    cards.forEach((card, i) => {\n      const drawing = card.hidden ? cardCache.get('hidden') : cardCache.get(getKey(card))\n      if (drawing) {\n        const x = stack.direction === StackDirection.horizontal ? i * space : 0\n        const y = stack.direction === StackDirection.horizontal ? 0 : i * space\n        elements.push({ data: drawing, x: box.x + x, y: box.y + y })\n      }\n    })\n\n  for (const { data, x, y } of elements) data && writeDataToCanvas(context, data, x, y)\n  return { path, box }\n}\n","import * as React from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { getScoringType, getScore } from '../redux/selectors'\nimport { ScoringType } from '../redux/game-state'\nimport { initialize } from '../redux/thunks'\nimport { useDrawing } from '../hooks/useDrawing'\nimport { drawLabel, getLabelDrawingContext } from '../drawing/Label'\nimport { GameCtx } from './GameCanvas'\nimport { getHorizontalMarginSize, getVerticalMarginSize } from '../drawing/Layout'\n\nconst TopBar: React.FC = () => {\n  const dispatch = useDispatch()\n  const gameContext = React.useContext(GameCtx)\n  const scoringType = useSelector(getScoringType)\n  const currentScore = useSelector(getScore)\n\n  const otherGameType = React.useMemo(\n    () => (scoringType === ScoringType.vegas ? ScoringType.regular : ScoringType.vegas),\n    [scoringType],\n  )\n\n  const deets = React.useMemo(() => {\n    if (gameContext == null) return null\n\n    const newGame = getLabelDrawingContext(gameContext.context, {\n      x: 5,\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: 'New Game',\n      border: true,\n    })\n\n    const switchGame = getLabelDrawingContext(gameContext.context, {\n      x: newGame.box.x + newGame.box.width + getHorizontalMarginSize(gameContext.context),\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: `Switch to ${ScoringType[otherGameType]}`,\n      border: true,\n    })\n\n    const score = getLabelDrawingContext(gameContext.context, {\n      x: 0,\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: `Score: ${currentScore}`,\n      border: false,\n    })\n\n    const version = getLabelDrawingContext(gameContext.context, {\n      x: 0,\n      y: 5,\n      height: 15,\n      padding: 5,\n      label: process.env.version || '',\n      border: false,\n    })\n\n    // position the x of the switch game type button to the right of the new game button\n    switchGame.box.x = newGame.box.x + newGame.box.width + getHorizontalMarginSize(gameContext.context)\n\n    // position the x of the score to the very right of the board\n    score.box.x = gameContext.context.width - score.box.width - getHorizontalMarginSize(gameContext.context)\n\n    // version goes in the bottom right\n    version.box.x = gameContext.context.width - version.box.width - getHorizontalMarginSize(gameContext.context)\n    version.box.y = gameContext.context.height - version.box.height - getVerticalMarginSize(gameContext.context)\n\n    return { newGame, switchGame, score, version }\n  }, [gameContext, currentScore, otherGameType])\n\n  const handleNewGame = React.useCallback(() => dispatch(initialize()), [dispatch])\n\n  const handleSwitchGame = React.useCallback(() => dispatch(initialize(otherGameType)), [dispatch, otherGameType])\n\n  useDrawing((context) => deets && drawLabel(context, deets.newGame), { onClick: handleNewGame })\n\n  useDrawing((context) => deets && drawLabel(context, deets.switchGame), { onClick: handleSwitchGame })\n\n  useDrawing((context) => deets && drawLabel(context, deets.score))\n\n  useDrawing((context) => deets && drawLabel(context, deets.version))\n\n  return null\n}\n\nexport { TopBar }\nexport default React.memo(TopBar)\n","import { DrawRoutine, DrawingContext, Box } from './Common'\n\nimport { search, measureWidth } from './FontSize'\n\ntype LabelDrawingOpts = {\n  label: string\n  padding: number\n  x?: number\n  y: number\n  height: number\n  border?: boolean\n}\n\ntype LabelDrawingContext = LabelDrawingOpts & {\n  box: Box\n  font: string\n}\n\nexport const getLabelDrawingContext = (context: DrawingContext, opts: LabelDrawingOpts): LabelDrawingContext => {\n  const isBigEnough = (_: number, boxHeight: number) => boxHeight > height\n  const { ctx } = context\n  const { x, y, height, label } = opts\n  const font = search(context.ctx, isBigEnough, label)\n  const width = measureWidth(ctx, font, label)\n  return {\n    ...opts,\n    box: { x: x ?? 0, y, width: width + opts.padding * 2, height: height + opts.padding * 2 },\n    font,\n  }\n}\n\nexport const drawLabel: DrawRoutine<LabelDrawingContext> = (context, drawingOpts) => {\n  if (drawingOpts == null) return null\n  const { ctx } = context\n  const { font, box, label, padding, border } = drawingOpts\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(box.x, box.y, box.width, box.height)\n  ctx.closePath()\n  ctx.clip()\n\n  ctx.font = font\n  ctx.textAlign = 'left'\n  ctx.textBaseline = 'top'\n  ctx.fillText(label, box.x + padding, box.y + padding)\n\n  if (border) {\n    ctx.strokeStyle = context.colorScheme.buttonBorder\n    ctx.strokeRect(box.x, box.y, box.width, box.height)\n  }\n\n  ctx.restore()\n\n  const path = new Path2D()\n  path.rect(box.x, box.y, box.width, box.height)\n  path.closePath()\n\n  return { box, path }\n}\n"],"sourceRoot":""}