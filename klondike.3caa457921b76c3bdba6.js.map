{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lib/Card.ts","webpack:///./src/redux/selectors.ts","webpack:///./src/lib/util.ts","webpack:///./src/redux/undoable.ts","webpack:///./src/redux/game-state.ts","webpack:///./src/redux/thunks.ts","webpack:///./src/components/GameCanvas.tsx","webpack:///./src/redux/stacks.ts","webpack:///./src/redux/init.ts","webpack:///./src/lib/Persist.ts","webpack:///./src/drawing/Layout.ts","webpack:///./src/drawing/ColorScheme.ts","webpack:///./src/drawing/Common.ts","webpack:///./src/drawing/FontSize.ts","webpack:///./src/hooks/useDrawing.ts","webpack:///./src/index.tsx","webpack:///./src/components/App.tsx","webpack:///./src/store.ts","webpack:///./src/redux/index.ts","webpack:///./src/components/Container.tsx","webpack:///./src/components/Fireworks.tsx","webpack:///./src/drawing/Card.ts","webpack:///./src/hooks/useCanvasSize.ts","webpack:///./src/components/StackElement.tsx","webpack:///./src/drawing/Stack.ts","webpack:///./src/components/TopBar.tsx","webpack:///./src/drawing/Label.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","ValueType","SuitType","StackDirection","StackType","Cards","values","suit","freeze","getStacks","createSelector","state","stacks","present","getFoundation","filter","stack","type","foundation","getTableau","tableau","getGameWon","every","cards","getHiddenCard","reduce","acc","topCard","getTopCard","hidden","stackCard","getMovableToFoundation","some","f","isValidFoundationMove","card","getStock","stock","getWaste","waste","getFoundationStack","_","find","getGameState","gameState","score","getScore","getScoringType","scoringType","getDraws","draws","getShowing","showing","getSelection","selection","disallowClickStock","rnd","Math","imul","min","max","floor","sumConsecutive","random","sameStack","stack1","stack2","index","sameCard","stackCard1","stackCard2","stackContainsCard","stackCards","item","isSequential","card1","valueToInt","isRed","diamond","heart","includes","isBlack","club","spade","isBig","ace","jack","queen","king","desintation","isValidTableauMove","destination","parseInt","destroy","UNDO","undo","REDO","redo","checkpoint","undoable","reducer","initialState","past","undefined","future","action","previous","next","newFuture","newPresent","ScoringType","ScoreType","getScoreChange","scoreType","regular","tableauToFoundation","wasteToFoundation","vegas","revealCard","wasteToTableau","foundationToTableau","incrementScore","decrementDraws","Infinity","retrieve","PersistanceType","gameMode","INITIALIZE","MOVE_CARDS","to","from","initialize","newScoringType","dispatch","getState","availableCards","Array","performMoves","movable","checkAndPerformCardReveal","checkAndPerformFoundationMove","reveal","deselectCard","moveCards","clickCard","cardSelection","clickedCard","clickedStack","selected","selectCard","throwStock","recycleWaste","doubleClickCard","GameCtx","React","createContext","intersect","evt","pointsRef","nativeEvent","e","canvas","target","point","x","offsetX","y","offsetY","ctx","getContext","path","keys","isPointInPath","thing","GameCanvas","children","useRef","Map","clickHandlers","doubleClickHandlers","width","height","handleCanvasRef","useCanvasSize","colorSchemeType","setColorScheme","useState","theme","ColorSchemeType","dark","colorScheme","colorSchemes","context","useMemo","useLayoutEffect","newTheme","persist","events","current","set","onClick","onDoubleClick","delete","handleCanvasDoubleClick","useCallback","event","handleCanvasClick","id","style","backgroundColor","background","top","left","position","ref","innerWidth","innerHeight","Provider","memo","SELECT","DESELECT","REVEAL_TOP","reverse","from_card","findIndex","reducers","map","a","direction","horizontal","vertical","localStorage","setItem","JSON","stringify","err","init","getItem","parse","getStackCardOffsetWidth","getStackCardOffsetHeight","getVerticalMarginSize","getHorizontalMarginSize","getTopbarBox","getCardDimensions","horizontalMargin","verticalMargin","topBarBox","stackCardOffsetHeight","usedVerticalSpace","usedHorizontalSpace","maxWidth","maxHeight","getStackBox","topBar","cardLength","usedWidth","baseX","stackWidth","stackHeight","emptyColor","faceUp","faceDown","buttonBorder","cardBorder","black","red","errorColor","light","c2","getKey","toString","cardCache","getHiddenImageData","getEmptyImageData","getErrorImageData","forEach","getCardImageData","document","createElement","clearRect","writeDataToCanvas","ctx2","putImageData","drawImage","allFontSizes","v","k","measureWidth","font","text","measureText","measureHeight","searchFontSize","isBigEnough","search","useDrawing","draw","gameContext","useContext","performCleanup","lastWidth","lastHeight","useEffect","add","remove","box","offline","install","applyUpdate","location","reload","ReactDOM","render","getElementById","App","store","middleware","createStore","applyMiddleware","combineReducers","hot","useDispatch","useSelector","handler","keyCode","ctrlKey","shiftKey","addEventListener","removeEventListener","button","preventDefault","fireworksObj","active","display","FireworksCanvas","ev","stop","start","FontSizeType","getBoxPath","radius","smaller","Path2D","dx","dy","dw","dh","moveTo","lineTo","quadraticCurveTo","closePath","getGlyphLocations","cardWidth","cardHeight","gutterHeight","gutterWidth","cornerWidth","figureOutFontSize","Corner","fontSizes","Regular","cornerValueX","cornerValueY","cornerSuitX","cornerSuitY","positions","glyph","rotated","textAlign","textBaseline","pos","three","five","nine","two","four","six","seven","eight","ten","getTop","getLeft","getTextAlign","fillStyle","fillRect","lineWidth","strokeStyle","strokeRect","getImageData","stroke","fill","save","translate","rotate","PI","fillText","restore","setCanvas","getSize","size","setSize","tid","handleSize","clearTimeout","setTimeout","StackElement","drawingOpts","getStackDrawingContext","prop","space","drawStack","opts","rect","empty","error","elements","drawing","TopBar","currentScore","handleThemeChange","changeTheme","otherGameType","deets","lightSwitch","getLabelDrawingContext","label","padding","border","newGame","switchGame","version","handleNewGame","handleSwitchGame","drawLabel","boxHeight","beginPath","clip"],"mappings":"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","file":"klondike.3caa457921b76c3bdba6.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([25,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export enum ValueType {\n  ace = 'A',\n  two = '2',\n  three = '3',\n  four = '4',\n  five = '5',\n  six = '6',\n  seven = '7',\n  eight = '8',\n  nine = '9',\n  ten = '10',\n  jack = 'J',\n  queen = 'Q',\n  king = 'K',\n}\n\nexport enum SuitType {\n  heart = '\\u2665',\n  diamond = '\\u2666',\n  spade = '\\u2660',\n  club = '\\u2663',\n}\n\nexport type Card = {\n  suit: SuitType\n  value: ValueType\n}\n\nexport type StackCard = {\n  card: Card\n  hidden?: boolean\n  selected?: boolean\n}\n\nexport enum StackDirection {\n  horizontal = 'horizontal',\n  vertical = 'vertical',\n}\n\n//\n//  1 2   3 3 3 3\n//  4 4 4 4 4 4 4\n//\n// 1 - stock\n// 2 - waste\n// 3 - foundation\n// 4 - tableau\n//\n\nexport enum StackType {\n  tableau = 'tableau',\n  foundation = 'foundation',\n  stock = 'stock',\n  waste = 'waste',\n}\n\nexport type Stack = {\n  cards: StackCard[]\n  selection: StackCard | null\n  type: StackType\n  direction: StackDirection | null\n  index: number\n}\n\nconst Cards: Card[] = []\n\nfor (const value of Object.values(ValueType)) {\n  for (const suit of Object.values(SuitType)) {\n    Cards.push({ suit, value })\n  }\n}\n\nObject.freeze(Cards)\n\nexport { Cards }\n","import { createSelector } from 'reselect'\nimport { StoreState } from './index'\nimport { Card, Stack, StackType, StackCard } from '../lib/Card'\nimport { getTopCard, isValidFoundationMove } from '../lib/util'\n\nexport type CardSelection = { stackCard?: StackCard; stack: Stack }\n\nexport const getStacks = createSelector(\n  (state: StoreState) => state.stacks.present.stacks,\n  (stacks) => stacks,\n)\n\nconst getFoundation = createSelector(getStacks, (stacks) =>\n  stacks.filter((stack) => stack.type === StackType.foundation),\n)\n\nconst getTableau = createSelector(getStacks, (stacks) => stacks.filter((stack) => stack.type === StackType.tableau))\n\nexport const getGameWon = createSelector(getFoundation, (foundation) =>\n  foundation.every((stack) => stack.cards.length === 13),\n)\n\nexport const getHiddenCard = createSelector(getTableau, (stacks) =>\n  stacks.reduce<CardSelection | null>((acc, stack) => {\n    if (acc) return acc\n    const topCard = getTopCard(stack.cards)\n    if (topCard && topCard.hidden) return { stack, stackCard: topCard }\n    return null\n  }, null),\n)\n\nexport const getMovableToFoundation = createSelector([getStacks, getFoundation], (stacks, foundation) =>\n  stacks\n    .filter((stack) => stack.type !== StackType.foundation)\n    .reduce<CardSelection | null>((acc, stack) => {\n      if (acc) return acc\n      const topCard = getTopCard(stack.cards)\n      if (topCard == null || topCard.hidden) return acc\n      if (foundation.some((f) => isValidFoundationMove(topCard.card, getTopCard(f.cards))))\n        return { stack, stackCard: topCard }\n      return null\n    }, null),\n)\n\nexport const getStock = createSelector(\n  getStacks,\n  (stacks) => stacks.filter((stack) => stack.type === StackType.stock)[0],\n)\n\nexport const getWaste = createSelector(\n  getStacks,\n  (stacks) => stacks.filter((stack) => stack.type === StackType.waste)[0],\n)\n\nexport const getFoundationStack = createSelector(\n  getFoundation,\n  (_: unknown, card: Card) => card,\n  (foundation, card) => foundation.find((stack) => isValidFoundationMove(card, getTopCard(stack.cards))),\n)\n\nexport const getGameState = createSelector(\n  (state: StoreState) => state.gameState.present,\n  (score) => score,\n)\n\nexport const getScore = createSelector(getGameState, (score) => score.score)\n\nexport const getScoringType = createSelector(getGameState, (score) => score.scoringType)\n\nexport const getDraws = createSelector(getGameState, ({ draws }) => draws)\n\nexport const getShowing = createSelector(getGameState, ({ showing }) => showing)\n\nexport const getSelection = createSelector(getStacks, (stacks) => {\n  const stack = stacks.find((stack) => stack.selection != null)\n  if (stack) return { stackCard: stack.selection as StackCard, stack: stack }\n  return null\n})\n\nexport const disallowClickStock = createSelector(\n  [getStock, getDraws],\n  (stock, draws) => stock.cards.length === 0 && draws === 0,\n)\n","import { Card, ValueType, SuitType, Stack, StackCard } from './Card'\n\n// minstd_rand\nexport const rnd = (s: number) => {\n  const rnd = () => ((2 ** 31 - 1) & (s = Math.imul(48271, s))) / 2 ** 31\n  rnd() // first call is always junk\n  return (min: number, max: number) => Math.floor(rnd() * (max - min + 1)) + min\n}\n\nexport const sumConsecutive = (i: number) => (i * (i + 1)) / 2\n\nexport const getTopCard = (cards: StackCard[]): StackCard | null => cards[cards.length - 1]\n\nexport const random = (min: number, max: number): number => Math.floor(Math.random() * max) + min\n\n// for simplicity, these routines would just use strict object comparison\n// however, if doing that, any changes to the store in a thunk would invalidate variable reference\n// this is useful for comparing a selected, or checking if stacks are the same before modifying them\n// so, we compare both value/suit when doing card comparisons, and type/index for stack comparisons\n\nexport const sameStack = (stack1: Stack, stack2: Stack) => stack1.type === stack2.type && stack1.index === stack2.index\n\nexport const sameCard = (stackCard1: StackCard, stackCard2: StackCard) =>\n  stackCard1.card.value === stackCard2.card.value && stackCard1.card.suit === stackCard2.card.suit\n\nexport const stackContainsCard = (stackCards: StackCard[], stackCard: StackCard) =>\n  stackCards.some((item: StackCard) => sameCard(item, stackCard))\n\nexport const isSequential = (card: Card, card1: Card) => valueToInt(card1.value) + 1 === valueToInt(card.value)\n\nexport const isRed = (card: Card) => [SuitType.diamond, SuitType.heart].includes(card.suit)\n\nexport const isBlack = (card: Card) => [SuitType.club, SuitType.spade].includes(card.suit)\n\nexport const isBig = (card: Card) =>\n  [ValueType.ace, ValueType.jack, ValueType.queen, ValueType.king].includes(card.value)\n\nexport const isValidFoundationMove = (card: Card, desintation: StackCard | null) =>\n  desintation == null\n    ? card.value === ValueType.ace\n    : desintation.card.suit === card.suit && isSequential(card, desintation.card)\n\nexport const isValidTableauMove = (card: Card, destination?: StackCard) => {\n  return destination == null\n    ? card.value === ValueType.king\n    : isSequential(destination.card, card) &&\n        ((isRed(card) && isBlack(destination.card)) || (isBlack(card) && isRed(destination.card)))\n}\n\nconst valueToInt = (value: ValueType): number => {\n  if (value === ValueType.ace) return 1\n  if (value === ValueType.jack) return 11\n  if (value === ValueType.queen) return 12\n  if (value === ValueType.king) return 13\n  return parseInt(value, 10)\n}\n","import { Reducer, AnyAction } from 'redux'\n\nexport type History<State> = {\n  past: State[]\n  present: State\n  future: State[]\n}\n\nconst DESTROY = '@@undoable/destroy'\nexport type DestroyAction = { type: typeof DESTROY }\nexport const destroy = (): DestroyAction => ({ type: DESTROY })\n\nconst UNDO = '@@undoable/undo'\ntype UndoAction = { type: typeof UNDO }\nexport const undo = (): UndoAction => ({ type: UNDO })\n\nconst REDO = '@@undoable/redo'\ntype RedoAction = { type: typeof REDO }\nexport const redo = (): RedoAction => ({ type: REDO })\n\nconst CHECKPOINT = '@@undoable/checkpoint'\ntype CheckpointAction = { type: typeof CHECKPOINT }\nexport const checkpoint = (): CheckpointAction => ({ type: CHECKPOINT })\n\nexport type UndoableActions = DestroyAction | UndoAction | RedoAction | CheckpointAction\n\nexport const undoable = <S, A extends AnyAction = UndoableActions>(reducer: Reducer<S, A>) => {\n  const initialState: History<S> = {\n    past: [],\n    present: reducer(undefined, {} as A),\n    future: [],\n  }\n\n  return (state = initialState, action: A) => {\n    const { past, present, future } = state\n\n    if (action.type === UNDO) {\n      const previous = past[past.length - 1]\n      if (!previous) {\n        return state\n      }\n\n      const newPast = past.slice(0, past.length - 1)\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future],\n      }\n    }\n\n    if (action.type === REDO) {\n      const next = future[0]\n      if (!next) {\n        return state\n      }\n\n      const newFuture = future.slice(1)\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture,\n      }\n    }\n\n    const newPresent = reducer(present, action)\n\n    if (action.type === DESTROY) {\n      return {\n        past: [],\n        present: newPresent,\n        future: [],\n      }\n    }\n\n    if (action.type === CHECKPOINT) {\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: [],\n      }\n    }\n\n    if (present === newPresent) {\n      return state\n    }\n\n    return {\n      past,\n      present: newPresent,\n      future,\n    }\n  }\n}\n","import { MOVE_CARDS } from './stacks'\nimport { StackType } from '../lib/Card'\nimport { StoreActions } from '.'\nimport { undoable } from './undoable'\nimport { INITIALIZE, InitializeAction } from './init'\nimport { retrieve, PersistanceType } from '../lib/Persist'\n\nexport enum ScoringType {\n  vegas,\n  regular,\n}\n\nexport enum ScoreType {\n  wasteToTableau = 'wasteToTableau',\n  wasteToFoundation = 'wasteToFoundation',\n  tableauToFoundation = 'tableauToFoundation',\n  revealCard = 'revealCard',\n  foundationToTableau = 'foundationToTableau',\n}\n\nexport type GameStateStore = {\n  score: number\n  showing: number\n  draws: number\n  scoringType: ScoringType\n}\n\nconst getScoreChange = (scoringType: ScoringType, scoreType: ScoreType) => {\n  let score = 0\n  if (scoringType === ScoringType.regular && scoreType === ScoreType.tableauToFoundation) {\n    score = 10\n  } else if (\n    scoreType === ScoreType.wasteToFoundation ||\n    (scoringType === ScoringType.vegas && scoreType === ScoreType.tableauToFoundation) ||\n    (scoringType === ScoringType.regular && scoreType === ScoreType.revealCard) ||\n    (scoringType === ScoringType.regular && scoreType === ScoreType.wasteToTableau)\n  ) {\n    score = 5\n  } else if (scoringType === ScoringType.regular && ScoreType.foundationToTableau) {\n    score = -10\n  } else if (scoringType === ScoringType.vegas && scoreType === ScoreType.foundationToTableau) {\n    score = -5\n  }\n  return score\n}\n\nconst INCREMENT_SCORE = '@@game-state/increment-score'\ntype IncrementScoreAction = { type: typeof INCREMENT_SCORE; scoreType: ScoreType }\nexport const incrementScore = (scoreType: ScoreType): IncrementScoreAction => ({ type: INCREMENT_SCORE, scoreType })\n\nconst DECREMENT_DRAWS = 'DECREMENT_DRAWS'\ntype DecrementDrawsAction = { type: typeof DECREMENT_DRAWS }\nexport const decrementDraws = (): DecrementDrawsAction => ({ type: DECREMENT_DRAWS })\n\nexport type GameStateActions = DecrementDrawsAction | IncrementScoreAction | InitializeAction\n\nconst initialState: GameStateStore = {\n  showing: 0,\n  score: 0,\n  draws: Infinity,\n  scoringType: retrieve(PersistanceType.gameMode, ScoringType.regular),\n}\n\nconst reducer = (state: GameStateStore = initialState, action: StoreActions): GameStateStore => {\n  if (action.type === INITIALIZE) {\n    return {\n      ...state,\n      scoringType: action.scoringType,\n      score: action.scoringType === ScoringType.vegas ? retrieve(PersistanceType.score, 0) - 52 : 0,\n      draws: action.scoringType === ScoringType.vegas ? 2 : Infinity,\n    }\n  }\n\n  if (action.type === DECREMENT_DRAWS) {\n    return {\n      ...state,\n      draws: state.draws - 1,\n    }\n  }\n\n  if (action.type === MOVE_CARDS) {\n    return action.to.type === StackType.waste || (action.from && action.from.type === StackType.waste)\n      ? {\n          ...state,\n          showing:\n            action.to.type === StackType.waste\n              ? Math.min(action.to.cards.length + action.cards.length, 3)\n              : Math.max(1, state.showing - 1),\n        }\n      : state\n  }\n\n  if (action.type === INCREMENT_SCORE) {\n    return {\n      ...state,\n      score: state.score + getScoreChange(state.scoringType, action.scoreType),\n    }\n  }\n  return state\n}\n\nexport default undoable(reducer)\n","import { ThunkAction, ThunkDispatch as ReduxThunkDispatch } from 'redux-thunk'\n\nimport { StoreState, StoreActions } from '.'\nimport { isValidTableauMove, random } from '../lib/util'\nimport { StackType, Card, Cards } from '../lib/Card'\n\nimport { moveCards, deselectCard, selectCard, reveal, throwStock, recycleWaste } from './stacks'\nimport {\n  getSelection,\n  getFoundationStack,\n  disallowClickStock,\n  getWaste,\n  getStock,\n  getScoringType,\n  getMovableToFoundation,\n  CardSelection,\n  getHiddenCard,\n} from './selectors'\nimport { checkpoint } from './undoable'\nimport { incrementScore, ScoreType, ScoringType, decrementDraws } from './game-state'\nimport { initialize as initializeGame } from './init'\n\nexport type ThunkResult<R, E = null> = ThunkAction<R, StoreState, E, StoreActions>\nexport type ThunkDispatch<E = null> = ReduxThunkDispatch<StoreState, E, StoreActions>\n\ninterface CardClickAction<T = void> {\n  (selection: CardSelection): ThunkResult<T>\n}\n\nexport const initialize = (newScoringType?: ScoringType): ThunkResult<void> => (dispatch, getState) => {\n  const scoringType = newScoringType == null ? getScoringType(getState()) : newScoringType\n  const availableCards = Array.from(Cards)\n  const cards: Card[] = []\n\n  for (let i = 0; i < 52; i++) {\n    const index = random(0, availableCards.length)\n    cards.push(...availableCards.splice(index, 1))\n  }\n\n  dispatch(initializeGame(scoringType, cards))\n}\n\nexport const performMoves = (): ThunkResult<void> => (dispatch, getState) => {\n  let movable: CardSelection | null\n  while ((movable = getMovableToFoundation(getState()) || getHiddenCard(getState()))) {\n    if (movable.stackCard?.hidden ?? false) {\n      dispatch(checkAndPerformCardReveal(movable))\n    } else {\n      dispatch(checkAndPerformFoundationMove(movable))\n    }\n  }\n}\n\nconst checkAndPerformCardReveal: CardClickAction = (selection) => (dispatch) => {\n  if (selection == null) return\n  dispatch(checkpoint())\n  dispatch(incrementScore(ScoreType.revealCard))\n  dispatch(reveal(selection.stack))\n}\n\nconst checkAndPerformFoundationMove: CardClickAction = (selection) => (dispatch, getState) => {\n  const foundation = (selection.stackCard && getFoundationStack(getState(), selection.stackCard.card)) || null\n  if (foundation && selection.stackCard) {\n    dispatch(deselectCard())\n    dispatch(checkpoint())\n    if (selection.stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToFoundation))\n    if (selection.stack.type === StackType.tableau) dispatch(incrementScore(ScoreType.tableauToFoundation))\n    dispatch(moveCards(selection.stack, foundation, selection.stackCard))\n  }\n}\n\nexport const clickCard: CardClickAction = (cardSelection) => (dispatch, getState) => {\n  const { stackCard: clickedCard, stack: clickedStack } = cardSelection\n  if (clickedCard != null && clickedCard.selected) return dispatch(deselectCard())\n\n  const selection = getSelection(getState())\n  if (selection == null && clickedCard && !clickedCard.hidden) return dispatch(selectCard(clickedStack, clickedCard))\n\n  if (clickedStack.type === StackType.foundation && selection) {\n    dispatch(checkAndPerformFoundationMove(selection))\n    return\n  }\n\n  if (clickedStack.type === StackType.tableau) {\n    if (selection == null && clickedCard && clickedCard.hidden) {\n      dispatch(checkpoint())\n      dispatch(incrementScore(ScoreType.revealCard))\n      dispatch(reveal(clickedStack))\n    }\n    if (selection && selection.stackCard && isValidTableauMove(selection.stackCard.card, clickedCard)) {\n      dispatch(deselectCard())\n      dispatch(checkpoint())\n      if (selection.stack.type === StackType.waste) dispatch(incrementScore(ScoreType.wasteToTableau))\n      if (selection.stack.type === StackType.foundation) dispatch(incrementScore(ScoreType.foundationToTableau))\n      dispatch(moveCards(selection.stack, clickedStack, selection.stackCard))\n    }\n  }\n\n  if (clickedStack.type === StackType.stock) {\n    if (disallowClickStock(getState())) return\n    if (selection) dispatch(deselectCard())\n    const waste = getWaste(getState())\n    const stock = getStock(getState())\n    dispatch(checkpoint())\n    if (stock.cards.length > 0) {\n      dispatch(throwStock(stock, waste))\n    } else {\n      dispatch(recycleWaste(waste, stock))\n      dispatch(decrementDraws())\n    }\n  }\n}\n\nexport const doubleClickCard: CardClickAction = (cardSelection) => (dispatch) => {\n  const { stack, stackCard } = cardSelection\n  if (\n    stack.type === StackType.foundation ||\n    stack.type === StackType.stock ||\n    stackCard == null ||\n    stackCard.card == null\n  ) {\n    return\n  }\n\n  dispatch(checkAndPerformFoundationMove({ stack, stackCard }))\n}\n","import * as React from 'react'\nimport { Drawable, DrawingContext, Clickable, Handler } from '../drawing/Common'\nimport { ColorSchemeType, colorSchemes } from '../drawing/ColorScheme'\nimport { initialize } from '../drawing/Common'\nimport { useCanvasSize } from '../hooks/useCanvasSize'\nimport { retrieve, PersistanceType, persist } from '../lib/Persist'\n\nexport type GameContext = {\n  context: DrawingContext\n  changeTheme: (newTheme: ColorSchemeType) => void\n  add: (thing: Drawable, events: Clickable) => void\n  remove: (path: Path2D) => void\n}\n\nexport const GameCtx = React.createContext<GameContext | null>(null)\n\nconst intersect = (evt: React.MouseEvent<HTMLCanvasElement>, pointsRef: Map<Path2D, Drawable>) => {\n  const { nativeEvent: e } = evt\n  const canvas = e.target as HTMLCanvasElement\n  const point = { x: e.offsetX, y: e.offsetY }\n  const ctx = canvas.getContext('2d')\n  for (const path of pointsRef.keys())\n    if (ctx?.isPointInPath(path, point.x, point.y)) {\n      const thing = pointsRef.get(path)\n      if (thing == null) return\n      return { thing, point }\n    }\n}\n\nconst GameCanvas: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const pointsRef = React.useRef<Map<Path2D, Drawable>>(new Map())\n  const clickHandlers = React.useRef<Map<Path2D, Handler>>(new Map())\n  const doubleClickHandlers = React.useRef<Map<Path2D, Handler>>(new Map())\n\n  const { ctx, width, height, handleCanvasRef } = useCanvasSize()\n\n  const [colorSchemeType, setColorScheme] = React.useState(retrieve(PersistanceType.theme, ColorSchemeType.dark))\n  const colorScheme = colorSchemes[colorSchemeType]\n\n  const context = React.useMemo<DrawingContext | null>(() => {\n    if (!width || !height || !ctx) return null\n    return { ctx, width, height, colorSchemeType, colorScheme }\n  }, [ctx, width, height, colorSchemeType, colorScheme])\n\n  React.useLayoutEffect(() => (context && initialize(context)) || void 0, [context])\n\n  const value = React.useMemo<GameContext | null>(\n    () =>\n      context && {\n        context,\n        changeTheme(newTheme) {\n          setColorScheme(newTheme)\n          persist(PersistanceType.theme, newTheme)\n        },\n        add(thing, events) {\n          pointsRef.current.set(thing.path, thing)\n          if (events.onClick) clickHandlers.current.set(thing.path, events.onClick)\n          if (events.onDoubleClick) doubleClickHandlers.current.set(thing.path, events.onDoubleClick)\n        },\n        remove(path: Path2D) {\n          pointsRef.current.delete(path)\n          clickHandlers.current.delete(path)\n          doubleClickHandlers.current.delete(path)\n        },\n      },\n    [context],\n  )\n\n  const handleCanvasDoubleClick = React.useCallback((evt: React.MouseEvent<HTMLCanvasElement>) => {\n    const selection = intersect(evt, pointsRef.current)\n    if (selection) {\n      const { thing, point } = selection\n      const event = doubleClickHandlers.current.get(thing.path)\n      if (event) event(thing, point)\n    }\n  }, [])\n\n  const handleCanvasClick = React.useCallback((evt: React.MouseEvent<HTMLCanvasElement>) => {\n    const selection = intersect(evt, pointsRef.current)\n    if (selection) {\n      const { thing, point } = selection\n      const event = clickHandlers.current.get(thing.path)\n      if (event) event(thing, point)\n    }\n  }, [])\n\n  return (\n    <>\n      <canvas\n        id=\"canvas\"\n        style={{\n          backgroundColor: colorScheme.background,\n          top: '0',\n          left: '0',\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n        }}\n        ref={handleCanvasRef}\n        width={window.innerWidth}\n        height={window.innerHeight}\n        onClick={handleCanvasClick}\n        onDoubleClick={handleCanvasDoubleClick}\n      />\n      <GameCtx.Provider value={value}>{children}</GameCtx.Provider>\n    </>\n  )\n}\n\nexport { GameCanvas }\nexport default React.memo(GameCanvas)\n","import { Stack, StackCard, StackType, StackDirection } from '../lib/Card'\nimport { stackContainsCard, sumConsecutive, sameStack, sameCard } from '../lib/util'\nimport { undoable } from './undoable'\nimport { INITIALIZE, InitializeAction } from './init'\n\nexport const SELECT = '@@global/select-card'\nexport type SelectAction = { type: typeof SELECT; stack: Stack; card: StackCard }\nexport const selectCard = (stack: Stack, card: StackCard): SelectAction => ({ type: SELECT, card, stack })\n\nexport const DESELECT = '@@global/deselect-card'\nexport type DeselectAction = { type: typeof DESELECT }\nexport const deselectCard = (): DeselectAction => ({ type: DESELECT })\n\nexport const REVEAL_TOP = '@@global/reveal-top'\nexport type RevealTopCardAction = { type: typeof REVEAL_TOP; stack: Stack }\nexport const reveal = (stack: Stack): RevealTopCardAction => ({ type: REVEAL_TOP, stack })\n\nexport const MOVE_CARDS = '@@global/move-cards'\nexport type MoveCardAction = { type: typeof MOVE_CARDS; from?: Stack; to: Stack; cards: StackCard[]; hidden: boolean }\n\n// move 3 cards from the stock to the waste\nexport const throwStock = (stock: Stack, waste: Stack): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from: stock,\n  to: waste,\n  cards: stock.cards.slice(-3).reverse(),\n  hidden: false,\n})\n\n// move all cards from waste back to the stock\nexport const recycleWaste = (waste: Stack, stock: Stack): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from: waste,\n  to: stock,\n  cards: waste.cards.slice(0),\n  hidden: true,\n})\n\n// other general moves\nexport const moveCards = (from: Stack, to: Stack, from_card: StackCard | null): MoveCardAction => ({\n  type: MOVE_CARDS,\n  from,\n  to,\n  cards: from.cards.slice(from.cards.findIndex((card) => from_card && sameCard(card, from_card))),\n  hidden: false,\n})\n\nexport type CardActions = SelectAction | DeselectAction | RevealTopCardAction | MoveCardAction\n\nconst reducers: {\n  [key: string]: (state: StackStore, action: CardActions | InitializeAction) => StackStore\n} = {\n  [INITIALIZE]: (state, action: InitializeAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) => {\n      switch (stack.type) {\n        case StackType.foundation:\n        case StackType.waste:\n          return { ...stack, cards: [] }\n        case StackType.stock:\n          return { ...stack, cards: action.cards.slice(0, 24).map((card) => ({ card, hidden: true })) }\n        case StackType.tableau:\n          return {\n            ...stack,\n            cards: action.cards\n              .slice(24 + sumConsecutive(stack.index), 24 + sumConsecutive(stack.index) + stack.index + 1)\n              .map((card, index, a) => ({ card, hidden: a.length !== index + 1 })),\n          }\n      }\n    }),\n  }),\n  [SELECT]: (state, action: SelectAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      sameStack(stack, action.stack) && stackContainsCard(stack.cards, action.card)\n        ? {\n            ...stack,\n            selection: action.card,\n            cards: stack.cards.map((stackCard) =>\n              !sameCard(stackCard, action.card) ? stackCard : { ...stackCard, selected: true },\n            ),\n          }\n        : stack,\n    ),\n  }),\n  [DESELECT]: (state) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      stack.selection != null\n        ? {\n            ...stack,\n            selection: null,\n            cards: stack.cards.map((stackCard) =>\n              !stackCard.selected ? stackCard : { ...stackCard, selected: false },\n            ),\n          }\n        : stack,\n    ),\n  }),\n  [MOVE_CARDS]: (state, action: MoveCardAction) =>\n    state.stacks.some((stack) => sameStack(action.to, stack) || (action.from && sameStack(action.from, stack)))\n      ? {\n          ...state,\n          stacks: state.stacks.map((stack) =>\n            sameStack(stack, action.to)\n              ? {\n                  ...stack,\n                  cards: [\n                    ...stack.cards,\n                    ...action.cards.map((card) => ({ ...card, selected: false, hidden: action.hidden })),\n                  ],\n                }\n              : action.from && sameStack(stack, action.from)\n              ? {\n                  ...stack,\n                  cards: stack.cards.filter((stackCard) => !stackContainsCard(action.cards, stackCard)),\n                }\n              : stack,\n          ),\n        }\n      : state,\n  [REVEAL_TOP]: (state, action: RevealTopCardAction) => ({\n    ...state,\n    stacks: state.stacks.map((stack) =>\n      sameStack(stack, action.stack)\n        ? {\n            ...stack,\n            cards: stack.cards.map((card, index) =>\n              index < stack.cards.length - 1 ? card : { ...card, hidden: false },\n            ),\n          }\n        : stack,\n    ),\n  }),\n}\n\nexport type StackStore = {\n  readonly stacks: Stack[]\n}\n\nconst initialState: StackStore = {\n  stacks: [\n    {\n      type: StackType.stock,\n      direction: null,\n      cards: [],\n      index: 0,\n      selection: null,\n    },\n    {\n      type: StackType.waste,\n      direction: StackDirection.horizontal,\n      cards: [],\n      index: 0,\n      selection: null,\n    },\n    ...Array.from<number, Stack>({ length: 7 }, (_, index) => ({\n      index,\n      type: StackType.tableau,\n      direction: StackDirection.vertical,\n      cards: [],\n      selection: null,\n    })),\n    ...Array.from<number, Stack>({ length: 4 }, (_, index) => ({\n      index,\n      type: StackType.foundation,\n      direction: null,\n      cards: [],\n      selection: null,\n    })),\n  ],\n}\n\nconst reducer = (state: StackStore = initialState, action: CardActions): StackStore => {\n  const r = reducers[action.type]\n  if (r) return r(state, action)\n  return state\n}\n\nexport default undoable(reducer)\n","import { ScoringType } from './game-state'\nimport { Card } from '../lib/Card'\n\n// this is in it's own file because circular dependencies are jerks.\n\nexport const INITIALIZE = '@@game-state/initialize'\nexport type InitializeAction = { type: typeof INITIALIZE; scoringType: ScoringType; cards: Card[] }\nexport const initialize = (scoringType: ScoringType, cards: Card[]): InitializeAction => ({\n  type: INITIALIZE,\n  scoringType,\n  cards,\n})\n","export enum PersistanceType {\n  gameMode = 'game-mode',\n  theme = 'theme',\n  score = 'score',\n}\n\nexport const persist: <T>(name: PersistanceType, thing: T) => void = (name, thing) => {\n  try {\n    localStorage.setItem(name, JSON.stringify(thing))\n  } catch (err) {\n    // that sucks\n  }\n}\n\nexport const retrieve = <T>(name: PersistanceType, init: T) => {\n  try {\n    const thing = localStorage.getItem(name) || ''\n    return JSON.parse(thing) as T\n  } catch (err) {\n    return init\n  }\n}\n","import { DrawingContext, Box, Dimensions } from './Common'\nimport { Stack, StackDirection, StackType } from '../lib/Card'\n\nexport const getStackCardOffsetWidth = (ctx: DrawingContext) => Math.floor(ctx.height * 0.03)\n\nexport const getStackCardOffsetHeight = (ctx: DrawingContext) => Math.floor(ctx.height * 0.03)\n\nexport const getVerticalMarginSize = (ctx: DrawingContext) => Math.floor(ctx.height * 0.01)\n\nexport const getHorizontalMarginSize = (ctx: DrawingContext) => Math.floor(ctx.width * 0.01)\n\nexport const getTopbarBox = (): Box => ({ x: 0, y: 0, width: 0, height: 30 })\n\n// the goal is to find the highest possible card width/height satisfying the desired ratio\n// assuming a fixed top-bar height with no margin, ( it will account for its own padding )\n// and 1 vertical separator + 6 horizontal separators\n// also, need room to stack 13 stack + 6 hidden => 19 cards.\n// without exceeding the size of the window.\n\nexport const getCardDimensions = (ctx: DrawingContext): Dimensions => {\n  const horizontalMargin = getHorizontalMarginSize(ctx)\n  const verticalMargin = getVerticalMarginSize(ctx)\n  const topBarBox = getTopbarBox()\n  const stackCardOffsetHeight = getStackCardOffsetHeight(ctx)\n\n  const usedVerticalSpace = topBarBox.height + verticalMargin * 2 + stackCardOffsetHeight * 19\n  const usedHorizontalSpace = horizontalMargin * 6\n\n  const maxWidth = Math.floor((ctx.width - usedHorizontalSpace) / 7)\n  const maxHeight = Math.floor((ctx.height - usedVerticalSpace) / 1.5)\n\n  const DESIRED_RATIO = 1.618 // try to get golden ratio size cards\n  const width = maxWidth * DESIRED_RATIO < maxHeight ? maxWidth : maxHeight / DESIRED_RATIO\n  const height = maxWidth * DESIRED_RATIO < maxHeight ? maxWidth * DESIRED_RATIO : maxHeight\n\n  return {\n    width: Math.floor(width),\n    height: Math.floor(height),\n  }\n}\n\nexport const getStackBox = (ctx: DrawingContext, stack: Stack, max: number): Box => {\n  const verticalMargin = getVerticalMarginSize(ctx)\n  const horizontalMargin = getHorizontalMarginSize(ctx)\n  const topBar = getTopbarBox()\n  const { width, height } = getCardDimensions(ctx)\n  const cardLength = Math.min(stack.cards.length, max)\n\n  // we know horizontal space used\n  // it might be less than available width\n  // base x width is half that available space (for centering)\n\n  const usedWidth = horizontalMargin * 6 + width * 7\n  const baseX = usedWidth < ctx.width ? (ctx.width - usedWidth) / 2 : 0\n\n  const stackWidth =\n    stack.direction === StackDirection.horizontal\n      ? cardLength === 0\n        ? height\n        : getStackCardOffsetWidth(ctx) * (cardLength - 1) + width\n      : width\n\n  const stackHeight =\n    stack.direction === StackDirection.vertical\n      ? cardLength === 0\n        ? height\n        : getStackCardOffsetHeight(ctx) * (cardLength - 1) + height\n      : height\n\n  switch (stack.type) {\n    case StackType.stock:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX,\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.waste:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX + horizontalMargin + width,\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.foundation:\n      return {\n        y: topBar.height + verticalMargin,\n        x: baseX + 3 * horizontalMargin + 3 * width + stack.index * (horizontalMargin + width),\n        width: stackWidth,\n        height: stackHeight,\n      }\n    case StackType.tableau:\n      return {\n        y: topBar.height + verticalMargin * 3 + height,\n        x: baseX + stack.index * (horizontalMargin + width),\n        width: stackWidth,\n        height: stackHeight,\n      }\n  }\n}\n","export enum ColorSchemeType {\n  dark,\n  light,\n}\n\nexport type ColorScheme = {\n  background: string\n  faceDown: string\n  buttonBorder: string\n  cardBorder: string\n  faceUp: string\n  selected: string\n  red: string\n  black: string\n  emptyColor: string\n  errorColor: string\n}\n\nexport const colorSchemes: { [key in ColorSchemeType]: ColorScheme } = {\n  [ColorSchemeType.dark]: {\n    background: '#000',\n    emptyColor: '#060606',\n    faceUp: '#222',\n    faceDown: '#333',\n    buttonBorder: '#ddd',\n    cardBorder: '#000',\n    black: '#999',\n    red: '#900',\n    selected: '#660',\n    errorColor: '#900',\n  },\n  [ColorSchemeType.light]: {\n    background: '#fff',\n    emptyColor: '#eee',\n    faceUp: '#ddd',\n    faceDown: '#ccc',\n    buttonBorder: '#000',\n    cardBorder: '#333',\n    black: '#333',\n    red: 'crimson',\n    selected: 'yellow',\n    errorColor: 'red',\n  },\n}\n","import { Cards, StackCard } from '../lib/Card'\nimport { ColorScheme, ColorSchemeType } from './ColorScheme'\nimport { getErrorImageData, getEmptyImageData, getHiddenImageData, getCardImageData } from './Card'\nimport { getCardDimensions } from './Layout'\n\n// this is passed to all drawing routines. it includes :\n// the color they should draw,\n// the ctx to draw it on, and\n// the width/height of the canvas.\n\nexport type DrawingContext = {\n  ctx: CanvasRenderingContext2D\n  colorScheme: ColorScheme\n  colorSchemeType: ColorSchemeType\n} & Dimensions\n\nexport type Dimensions = { width: number; height: number }\n\nexport type Point = { x: number; y: number }\n\nexport type Box = Dimensions & Point\n\n// something that is drawable includes an x/y coords and a height/width\n// once removed, clearRect is with these values to clean it from the canvas\n// also, the click/double click handlers will inspect if point is in their path.\n\nexport type Drawable = { path: Path2D; box: Box }\n\n// a draw routine takes drawing context above, and include whatever options they want\n// they perform mutations to the cavas (draw the thing) and return a drawable for tracking (above)\n\nexport interface DrawRoutine<DrawingOpts> {\n  (context: DrawingContext, arg1: DrawingOpts | null): Drawable | null\n}\n\nexport interface Handler {\n  (arg0: Drawable, arg1: Point): void\n}\n\nexport type Clickable = { onClick?: Handler; onDoubleClick?: Handler }\n\n// a cache of cards is kept and re-initialized when color scheme / window dimensions change\n// this is a map of a key identifying the stack card, and the raw pixel data to draw it.\n// the idea is this is all cached one time at the beginning and re-used\n\n// this uses a string with keys because it's actually a \"StackCard\" we're interested in\n// this includes the selected flag - the highlighted / non-highlighted state need to both be kept\n// while `Cards` is immutable singleton of all available cads, StackCards is not and\n// using a non-string key, we'll wind up with missing references not hitting the cache.\n\nexport const getKey = ({ card: { suit, value }, selected }: StackCard) =>\n  `${suit}_${value}_${(selected || false).toString()}`\n\nexport const cardCache: Map<string, ImageData> = new Map()\n\nlet c2: HTMLCanvasElement\n\nexport const initialize = (context: DrawingContext) => {\n  const { width, height } = getCardDimensions(context)\n  cardCache.set('hidden', getHiddenImageData(context))\n  cardCache.set('empty', getEmptyImageData(context))\n  cardCache.set('error', getErrorImageData(context))\n  Cards.forEach((card) => {\n    cardCache\n      .set(getKey({ card, selected: true }), getCardImageData(context, { card, selected: true }))\n      .set(getKey({ card, selected: false }), getCardImageData(context, { card, selected: false }))\n  })\n\n  c2 = document.createElement('canvas')\n  c2.width = width\n  c2.height = height\n  context.ctx.clearRect(0, 0, width + 2, height + 2)\n}\n\n// to get transarency working, (maybe other composition?) need an intermediary canvas to proxy the drawing.\n\nexport const writeDataToCanvas = (context: DrawingContext, data: ImageData, x: number, y: number) => {\n  const ctx2 = c2.getContext('2d')\n  ctx2?.putImageData(data, 0, 0)\n  context.ctx.drawImage(c2, x, y)\n}\n","const allFontSizes = Array.from<number, number>({ length: 200 }, (v, k) => k)\n\ninterface isBigEnough {\n  (width: number, height: number): boolean\n}\n\nexport const measureWidth = (ctx: CanvasRenderingContext2D, font: string, text: string) => {\n  ctx.font = font\n  return ctx.measureText(text).width\n}\n\nexport const measureHeight = (ctx: CanvasRenderingContext2D, font: string) => {\n  ctx.font = font\n  return ctx.measureText('M').width // close enough\n}\n\nconst searchFontSize = (\n  ctx: CanvasRenderingContext2D,\n  isBigEnough: isBigEnough,\n  text: string,\n  min: number,\n  max: number,\n): string => {\n  const index = Math.floor((max + min) / 2)\n  const font = `${allFontSizes[index]}px sans-serif`\n  const width = measureWidth(ctx, font, text)\n  const height = measureHeight(ctx, font)\n  if (min > max) return font\n  if (isBigEnough(width, height)) return searchFontSize(ctx, isBigEnough, text, min, index - 1)\n  return searchFontSize(ctx, isBigEnough, text, index + 1, max)\n}\n\nexport const search = (ctx: CanvasRenderingContext2D, isBigEnough: isBigEnough, text: string) =>\n  searchFontSize(ctx, isBigEnough, text, 0, allFontSizes.length - 1)\n","import * as React from 'react'\nimport { GameCtx } from '../components/GameCanvas'\nimport { Clickable, DrawingContext, Drawable } from '../drawing/Common'\n\nexport interface Drawer {\n  (context: DrawingContext): Drawable | null\n}\n\nexport const useDrawing = (draw: Drawer, events: Clickable = {}) => {\n  const gameContext = React.useContext(GameCtx)\n  const performCleanup = React.useRef(true)\n  const lastWidth = React.useRef(gameContext?.context.width ?? 0)\n  const lastHeight = React.useRef(gameContext?.context.height ?? 0)\n\n  // should only clear the rects if we haven't just resized the screen\n  // a screen resize will already clear the entire canvas\n  // if this isn't tracked, we end up drawing a new game and clear out the old sizes, leaving blank holes.\n\n  React.useLayoutEffect(() => {\n    if (!gameContext) return\n    performCleanup.current = !(\n      (lastHeight.current !== gameContext.context.height || lastWidth.current !== gameContext.context.width) &&\n      lastHeight.current > 0 &&\n      lastWidth.current > 0\n    )\n    lastHeight.current = gameContext.context.height\n    lastWidth.current = gameContext.context.width\n  }, [gameContext])\n\n  React.useEffect(() => {\n    if (gameContext == null) return\n    const { add, remove, context } = gameContext\n    const { ctx } = context\n\n    const thing = draw(context)\n    if (thing == null) return\n    add(thing, events)\n\n    return () => {\n      remove(thing.path)\n      if (performCleanup.current) {\n        ctx.clearRect(thing.box.x, thing.box.y, thing.box.width, thing.box.height)\n      }\n      performCleanup.current = true\n    }\n  })\n}\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport * as offline from 'offline-plugin/runtime'\n\nimport App from './components/App'\n\nconst NODE_ENV = process.env.NODE_ENV\nif (NODE_ENV === 'production') {\n  offline.install({\n    onUpdateReady() {\n      offline.applyUpdate()\n    },\n    onUpdated() {\n      window.location.reload()\n    },\n  })\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n","import * as React from 'react'\n\nimport { Provider } from 'react-redux'\n\nimport configStore from '../store'\nimport { ThunkDispatch, initialize } from '../redux/thunks'\nimport Container from './Container'\n\nconst App: React.FC = () => {\n  const store = configStore()\n  const dispatch = store.dispatch as ThunkDispatch\n\n  dispatch(initialize())\n\n  return (\n    <Provider store={store}>\n      <Container />\n    </Provider>\n  )\n}\n\nexport { App }\n\nexport default React.memo(App)\n","import { createStore, applyMiddleware } from 'redux'\nimport thunk, { ThunkMiddleware } from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport reducer, { StoreState, StoreActions } from './redux'\nimport subscribe from 'redux-subscribe-reselect'\nimport { getScoringType, getGameState } from './redux/selectors'\nimport { persist, PersistanceType } from './lib/Persist'\nimport { ScoringType } from './redux/game-state'\n\nexport default () => {\n  const middleware = []\n\n  middleware.push(thunk as ThunkMiddleware<StoreState, StoreActions>)\n\n  if (process.env.NODE_ENV !== 'production') {\n    middleware.push(\n      createLogger({\n        stateTransformer: (state: StoreState) => ({\n          gameState: state.gameState.present,\n          stacks: state.stacks.present,\n        }),\n      }),\n    )\n  }\n\n  const store = createStore(reducer, void 0, applyMiddleware(...middleware))\n  subscribe(store, getGameState, ({ scoringType, score }) => {\n    if (scoringType === ScoringType.vegas) persist(PersistanceType.score, score)\n  })\n  subscribe(store, getScoringType, (scoringType) => persist(PersistanceType.gameMode, scoringType))\n  return store\n}\n","import { combineReducers } from 'redux'\nimport stacks, { CardActions, StackStore } from './stacks'\nimport gameState, { GameStateActions, GameStateStore } from './game-state'\nimport { History, UndoableActions } from './undoable'\n\nexport type StoreActions = GameStateActions | CardActions | UndoableActions\n\nexport type StoreState = {\n  stacks: History<StackStore>\n  gameState: History<GameStateStore>\n}\n\nexport default combineReducers<StoreState, StoreActions>({ stacks, gameState })\n","import * as React from 'react'\nimport { hot } from 'react-hot-loader/root'\nimport { useDispatch, useSelector } from 'react-redux'\nimport FireworksComponent from './Fireworks'\nimport { undo, redo } from '../redux/undoable'\nimport GameCanvas from './GameCanvas'\nimport StackElement from './StackElement'\n\nimport { getDraws, getShowing, getStacks } from '../redux/selectors'\nimport TopBar from './TopBar'\nimport { performMoves } from '../redux/thunks'\nimport { StackType } from '../lib/Card'\n\nconst Container: React.FC = () => {\n  const dispatch = useDispatch()\n  const stacks = useSelector(getStacks)\n  const draws = useSelector(getDraws)\n  const showing = useSelector(getShowing)\n\n  React.useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.keyCode !== 90) return\n      if (e.ctrlKey && e.shiftKey) {\n        dispatch(redo())\n      } else if (e.ctrlKey) {\n        dispatch(undo())\n      }\n    }\n    document.addEventListener('keydown', handler)\n    return () => document.removeEventListener('keydown', handler)\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const handler = (e: MouseEvent) => {\n      if (e.button === 1) {\n        e.preventDefault()\n        dispatch(performMoves())\n      }\n    }\n    document.addEventListener('mousedown', handler)\n    return () => document.removeEventListener('mousedown', handler)\n  }, [dispatch])\n\n  return (\n    <div>\n      <FireworksComponent />\n      <GameCanvas>\n        <TopBar />\n        {stacks.map((stack) => (\n          <StackElement\n            key={`${stack.type}-${stack.index}`}\n            stack={stack}\n            showing={stack.type === StackType.waste ? showing : Infinity}\n            draws={stack.type === StackType.stock ? draws : Infinity}\n          />\n        ))}\n      </GameCanvas>\n    </div>\n  )\n}\n\nexport default hot(React.memo(Container))\n","import * as React from 'react'\nimport { useSelector } from 'react-redux'\nimport * as FireworksCanvas from 'fireworks-canvas'\nimport { getGameWon } from '../redux/selectors'\n\nconst Fireworks: React.FC = () => {\n  const ref = React.useRef<HTMLDivElement>(null)\n  const fireworksObj = React.useRef<FireworksCanvas>()\n  const active = useSelector(getGameWon)\n  const display = active ? '' : 'none'\n\n  React.useEffect(() => {\n    if (ref.current == null) return\n    fireworksObj.current = new FireworksCanvas(ref.current)\n\n    const handleDocumentKeyDown = (ev: KeyboardEvent) => {\n      if (ev.keyCode === 27) fireworksObj.current?.stop()\n    }\n\n    document.addEventListener('keydown', handleDocumentKeyDown)\n\n    return () => {\n      fireworksObj.current?.destroy()\n    }\n  }, [ref, active])\n\n  React.useEffect(() => {\n    if (active) {\n      fireworksObj.current?.stop()\n    } else {\n      fireworksObj.current?.start()\n    }\n  }, [active])\n\n  return (\n    <div\n      style={{\n        display,\n        top: '0',\n        left: '0',\n        width: '100vw',\n        height: '100vh',\n        position: 'absolute',\n      }}\n      ref={ref}\n    />\n  )\n}\n\nexport default React.memo(Fireworks)\n","import { ValueType, SuitType, StackCard } from '../lib/Card'\nimport { Box, DrawingContext } from './Common'\nimport { isBig, isRed } from '../lib/util'\nimport { search, measureHeight } from './FontSize'\n\nimport { getCardDimensions, getVerticalMarginSize, getHorizontalMarginSize } from './Layout'\n\ntype Glyph = {\n  glyph: ValueType | SuitType\n  x: number\n  y: number\n  rotated: boolean\n  textAlign: CanvasTextAlign\n  textBaseline: CanvasTextBaseline\n  font: string\n}\n\ninterface GetCard {\n  (context: DrawingContext, card?: StackCard): ImageData\n}\n\nexport const getBoxPath = ({ x, y, width, height }: Box, radius = 10, smaller = 0) => {\n  const path = new Path2D()\n\n  const dx = x + smaller\n  const dy = y + smaller\n  const dw = width - smaller * 2\n  const dh = height - smaller * 2\n\n  path.moveTo(dx + radius, dy)\n  path.lineTo(dx + dw - radius, dy)\n  path.quadraticCurveTo(dx + dw, dy, dx + dw, dy + radius)\n  path.lineTo(dx + dw, dy + dh - radius)\n  path.quadraticCurveTo(dx + dw, dy + dh, dx + dw - radius, dy + dh)\n  path.lineTo(dx + radius, dy + dh)\n  path.quadraticCurveTo(dx, dy + dh, dx, dy + dh - radius)\n  path.lineTo(dx, dy + radius)\n  path.quadraticCurveTo(dx, dy, dx + radius, dy)\n  path.closePath()\n  return path\n}\n\nenum FontSizeType {\n  Regular,\n  Corner,\n}\n\nexport const getGlyphLocations = (context: DrawingContext, { card, hidden }: StackCard): Glyph[] => {\n  if (hidden) return []\n\n  const { ctx } = context\n  const { width: cardWidth, height: cardHeight } = getCardDimensions(context)\n  const gutterHeight = getVerticalMarginSize(context)\n  const gutterWidth = getHorizontalMarginSize(context)\n\n  const cornerWidth = Math.floor(cardWidth * 0.2)\n  const figureOutFontSize = (type: FontSizeType) =>\n    search(\n      ctx,\n      (width: number, height: number) =>\n        type === FontSizeType.Corner\n          ? width > cornerWidth\n          : isBig(card)\n          ? width > cardWidth - Math.floor(cardWidth / 5) * 2\n          : width > Math.floor(cardWidth / 5) && height > Math.floor(cardHeight / 20),\n      type === FontSizeType.Corner ? '10' : '\\u2665',\n    )\n\n  const fontSizes: { [key in FontSizeType]: string } = {\n    [FontSizeType.Corner]: figureOutFontSize(FontSizeType.Corner),\n    [FontSizeType.Regular]: figureOutFontSize(FontSizeType.Regular),\n  }\n\n  // 20% of width is reserved for corner pieces\n  // y of suit is margin + height of value + margin\n  const cornerHeight = measureHeight(ctx, fontSizes[FontSizeType.Corner])\n\n  const cornerValueX = gutterWidth / 2\n  const cornerValueY = gutterHeight / 2\n  const cornerSuitX = gutterWidth / 2\n  const cornerSuitY = gutterWidth / 2 + cornerHeight\n\n  const { suit, value } = card\n\n  // top-left, bottom-right glyphs\n  const positions = [\n    { x: cornerValueX, y: cornerValueY, glyph: value },\n    { x: cornerSuitX, y: cornerSuitY, glyph: suit },\n  ].reduce((memo, glyph) => {\n    memo.push(\n      {\n        ...glyph,\n        rotated: false,\n        textAlign: 'left',\n        textBaseline: 'top',\n        font: fontSizes[FontSizeType.Corner],\n      },\n      {\n        ...glyph,\n        rotated: true,\n        textAlign: 'left',\n        textBaseline: 'top',\n        font: fontSizes[FontSizeType.Corner],\n      },\n    )\n    return memo\n  }, [] as Glyph[])\n\n  type ypos = 0 | 1 | 2 | 3 | 4 | 5 | 6\n\n  type xpos = 0 | 1 | 2\n\n  const pos: { x: xpos; y: ypos }[] = []\n\n  if (\n    [\n      ValueType.ace,\n      ValueType.three,\n      ValueType.five,\n      ValueType.nine,\n      ValueType.jack,\n      ValueType.queen,\n      ValueType.king,\n    ].includes(value)\n  ) {\n    pos.push({ x: 1, y: 3 })\n  }\n\n  if ([ValueType.two, ValueType.three].includes(value)) {\n    pos.push({ x: 1, y: 0 }, { x: 1, y: 6 })\n  }\n\n  if (\n    [\n      ValueType.four,\n      ValueType.five,\n      ValueType.six,\n      ValueType.seven,\n      ValueType.eight,\n      ValueType.nine,\n      ValueType.ten,\n    ].includes(value)\n  ) {\n    pos.push({ x: 0, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 6 }, { x: 2, y: 6 })\n  }\n\n  if ([ValueType.six, ValueType.seven, ValueType.eight].includes(value)) {\n    pos.push({ x: 0, y: 3 }, { x: 2, y: 3 })\n  }\n\n  if ([ValueType.seven, ValueType.ten, ValueType.eight].includes(value)) {\n    pos.push({ x: 1, y: 1 })\n  }\n\n  if ([ValueType.nine, ValueType.ten].includes(value)) {\n    pos.push({ x: 0, y: 2 }, { x: 2, y: 2 }, { x: 0, y: 4 }, { x: 2, y: 4 })\n  }\n\n  if ([ValueType.ten, ValueType.eight].includes(value)) {\n    pos.push({ x: 1, y: 5 })\n  }\n\n  const getTop = (y: ypos) => {\n    switch (y) {\n      case 0:\n      case 6:\n        return cardHeight * 0.2\n      case 1:\n      case 5:\n        return cardHeight * 0.3\n      case 2:\n      case 4:\n        return cardHeight * 0.4\n      case 3:\n        return cardHeight * 0.5\n    }\n  }\n\n  const getLeft = (x: xpos) => {\n    switch (x) {\n      case 0:\n        return cardWidth * 0.25\n      case 1:\n        return cardWidth * 0.5\n      case 2:\n        return cardWidth * 0.75\n    }\n  }\n\n  const getTextAlign = (x: xpos): CanvasTextAlign => {\n    switch (x) {\n      case 0:\n        return 'left'\n      case 1:\n        return 'center'\n      case 2:\n        return 'right'\n    }\n  }\n\n  pos.forEach(({ x, y }) => {\n    positions.push({\n      x: getLeft(x),\n      y: getTop(y),\n      glyph: suit,\n      textAlign: getTextAlign(x),\n      textBaseline: 'middle',\n      rotated: y > 3,\n      font: fontSizes[FontSizeType.Regular],\n    })\n  })\n\n  return positions\n}\n\nexport const getEmptyImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(0, 0, width, height)\n  ctx.fillStyle = colorScheme.emptyColor\n  ctx.fillRect(box.x, box.y, box.width, box.height)\n  ctx.lineWidth = 0.5\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.strokeRect(box.x, box.y, box.width, box.height)\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getHiddenImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.lineWidth = 2\n  ctx.stroke(getBoxPath(box, 10))\n  ctx.fillStyle = colorScheme.faceDown\n  ctx.fill(getBoxPath(box, 10, 0.5))\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getCardImageData: GetCard = (context: DrawingContext, card: StackCard) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.strokeStyle = colorScheme.cardBorder\n  ctx.lineWidth = 2\n  ctx.stroke(getBoxPath(box, 10))\n\n  ctx.fillStyle = card.selected ? colorScheme.selected : colorScheme.faceUp\n  ctx.fill(getBoxPath(box, 10, 0.5))\n\n  for (const glyph of getGlyphLocations(context, card)) {\n    ctx.fillStyle = isRed(card.card) ? colorScheme.red : colorScheme.black\n    ctx.textAlign = glyph.textAlign\n    ctx.textBaseline = glyph.textBaseline\n    ctx.font = glyph.font\n    if (glyph.rotated) {\n      ctx.save()\n      ctx.translate(width, height)\n      ctx.rotate(Math.PI)\n    }\n    ctx.fillText(glyph.glyph, glyph.x + box.x * (glyph.rotated ? -1 : 1), glyph.y + box.y * (glyph.rotated ? -1 : 1))\n    if (glyph.rotated) ctx.restore()\n  }\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n\nexport const getErrorImageData: GetCard = (context: DrawingContext) => {\n  const { ctx, colorScheme } = context\n  const { width, height } = getCardDimensions(context)\n  const box = { x: 0, y: 0, width, height }\n  ctx.clearRect(box.x, box.y, box.width, box.height)\n  ctx.fillStyle = colorScheme.emptyColor\n  ctx.fill(getBoxPath(box))\n  ctx.font = '48px sans-serif'\n  ctx.textAlign = 'center'\n  ctx.textBaseline = 'middle'\n  ctx.fillStyle = colorScheme.errorColor\n  ctx.fillText('X', box.width / 2, box.height / 2)\n  return ctx.getImageData(box.x, box.y, box.width, box.height)\n}\n","import * as React from 'react'\nimport { Dimensions } from '../drawing/Common'\n\ntype CanvasSizeReturn = {\n  ctx?: CanvasRenderingContext2D\n  width?: number\n  height?: number\n  handleCanvasRef: (canvas: HTMLCanvasElement) => void\n}\n\nexport const useCanvasSize = (): CanvasSizeReturn => {\n  const [canvas, setCanvas] = React.useState<HTMLCanvasElement | null>(null)\n  const handleCanvasRef = React.useCallback((canvas: HTMLCanvasElement) => canvas && setCanvas(canvas), [])\n\n  const getSize = () => ({ width: window.innerWidth, height: window.innerHeight })\n\n  const [size, setSize] = React.useState<Dimensions>()\n\n  React.useEffect(() => {\n    if (!canvas) return\n    const ctx = canvas.getContext('2d')\n    if (ctx == null) return\n    let tid: number\n    const handleSize = () => {\n      if (tid) clearTimeout(tid)\n      tid = window.setTimeout(() => setSize(getSize()), 300)\n    }\n    window.addEventListener('resize', handleSize)\n    return () => {\n      window.removeEventListener('resize', handleSize)\n    }\n  })\n\n  const retVal = React.useMemo(\n    () => ({\n      handleCanvasRef,\n      ...(canvas && {\n        ctx: canvas.getContext('2d') as CanvasRenderingContext2D,\n        ...(size ?? getSize()),\n      }),\n    }),\n    [size, handleCanvasRef, canvas],\n  )\n\n  return retVal\n}\n","import * as React from 'react'\nimport { GameCtx } from './GameCanvas'\nimport { drawStack, StackDrawingContext, getStackDrawingContext } from '../drawing/Stack'\nimport { Stack, StackDirection, StackType } from '../lib/Card'\nimport { useDispatch } from 'react-redux'\nimport { clickCard, doubleClickCard } from '../redux/thunks'\nimport { Point, Drawable } from '../drawing/Common'\nimport { useDrawing } from '../hooks/useDrawing'\nimport { useMemo } from 'react'\n\nconst StackElement: React.FC<{\n  stack: Stack\n  draws: number\n  showing: number\n}> = ({ stack, draws, showing }) => {\n  const dispatch = useDispatch()\n  const gameContext = React.useContext(GameCtx)\n\n  const drawingOpts = useMemo<StackDrawingContext | null>(\n    () => gameContext && getStackDrawingContext(gameContext.context, stack, { draws, showing }),\n    [gameContext, stack, draws, showing],\n  )\n\n  const onDoubleClick = React.useCallback(\n    (thing: Drawable, point: Point) => {\n      if (gameContext == null || drawingOpts == null) return\n      const prop = stack.direction === StackDirection.horizontal ? 'x' : 'y'\n      const cards = stack.cards.slice(-drawingOpts.max)\n      const index = Math.min(cards.length - 1, Math.floor((point[prop] - drawingOpts.box[prop]) / drawingOpts.space))\n      if (stack.type !== StackType.waste || index === cards.length - 1)\n        dispatch(doubleClickCard({ stack, stackCard: cards[index] }))\n    },\n    [dispatch, gameContext, drawingOpts, stack],\n  )\n\n  const onClick = React.useCallback(\n    (thing: Drawable, point: Point) => {\n      if (gameContext == null || drawingOpts == null) return\n      const prop = stack.direction === StackDirection.horizontal ? 'x' : 'y'\n      const cards = stack.cards.slice(-drawingOpts.max)\n      const index = Math.min(cards.length - 1, Math.floor((point[prop] - drawingOpts.box[prop]) / drawingOpts.space))\n      if (stack.type !== StackType.waste || index === cards.length - 1)\n        dispatch(clickCard({ stack, stackCard: cards[index] }))\n    },\n    [dispatch, gameContext, drawingOpts, stack],\n  )\n\n  useDrawing((context) => drawStack(context, drawingOpts), { onClick, onDoubleClick })\n\n  return null\n}\n\nexport { StackElement }\nexport default React.memo(StackElement)\n","import { Stack, StackDirection, StackType } from '../lib/Card'\nimport { writeDataToCanvas, cardCache, getKey, DrawingContext, DrawRoutine, Box } from './Common'\nimport { getStackCardOffsetWidth, getStackCardOffsetHeight, getStackBox } from './Layout'\n\nexport type StackDrawingOptions = {\n  draws: number\n  showing: number\n}\n\nexport type StackDrawingContext = StackDrawingOptions & {\n  stack: Stack\n  space: number\n  max: number\n  box: Box\n}\n\nexport const getStackDrawingContext = (\n  context: DrawingContext,\n  stack: Stack,\n  opts: StackDrawingOptions,\n): StackDrawingContext => {\n  const max =\n    stack.type === StackType.stock || stack.type === StackType.foundation\n      ? 1\n      : stack.type === StackType.waste\n      ? opts.showing || 0\n      : stack.cards.length\n\n  const box = getStackBox(context, stack, max)\n\n  const space =\n    stack.direction === StackDirection.horizontal ? getStackCardOffsetWidth(context) : getStackCardOffsetHeight(context)\n\n  return {\n    stack,\n    draws: opts.draws,\n    showing: opts.showing,\n    space,\n    box,\n    max,\n  }\n}\n\nexport const drawStack: DrawRoutine<StackDrawingContext> = (context, drawingOpts) => {\n  if (drawingOpts == null) return null\n  const { stack, draws, max, space, box } = drawingOpts\n  const cards = stack.cards.slice(-max)\n\n  const path = new Path2D()\n  path.rect(box.x, box.y, box.width, box.height)\n  path.closePath()\n\n  const empty = cards.length === 0\n  const error = stack.type === StackType.stock && empty && draws === 0\n  const elements = []\n\n  if (error) elements.push({ data: cardCache.get('error'), x: box.x, y: box.y })\n  else if (empty) elements.push({ data: cardCache.get('empty'), x: box.x, y: box.y })\n  else\n    cards.forEach((card, i) => {\n      const drawing = card.hidden ? cardCache.get('hidden') : cardCache.get(getKey(card))\n      if (drawing) {\n        const x = stack.direction === StackDirection.horizontal ? i * space : 0\n        const y = stack.direction === StackDirection.horizontal ? 0 : i * space\n        elements.push({ data: drawing, x: box.x + x, y: box.y + y })\n      }\n    })\n\n  for (const { data, x, y } of elements) data && writeDataToCanvas(context, data, x, y)\n  return { path, box }\n}\n","import * as React from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { getScoringType, getScore } from '../redux/selectors'\nimport { ScoringType } from '../redux/game-state'\nimport { initialize } from '../redux/thunks'\nimport { useDrawing } from '../hooks/useDrawing'\nimport { drawLabel, getLabelDrawingContext } from '../drawing/Label'\nimport { GameCtx } from './GameCanvas'\nimport { ColorSchemeType } from '../drawing/ColorScheme'\n\nconst TopBar: React.FC = () => {\n  const dispatch = useDispatch()\n  const gameContext = React.useContext(GameCtx)\n  const scoringType = useSelector(getScoringType)\n  const currentScore = useSelector(getScore)\n\n  const height = 15\n  const padding = 5\n\n  const handleThemeChange = React.useCallback(() => {\n    gameContext?.changeTheme(\n      gameContext.context.colorSchemeType === ColorSchemeType.dark ? ColorSchemeType.light : ColorSchemeType.dark,\n    )\n  }, [gameContext])\n\n  const otherGameType = React.useMemo(\n    () => (scoringType === ScoringType.vegas ? ScoringType.regular : ScoringType.vegas),\n    [scoringType],\n  )\n\n  const deets = React.useMemo(() => {\n    if (gameContext == null) return null\n\n    const lightSwitch = getLabelDrawingContext(gameContext.context, {\n      label: gameContext.context.colorSchemeType === ColorSchemeType.dark ? '' : '',\n      y: 5,\n      height,\n      padding,\n      border: false,\n    })\n\n    const newGame = getLabelDrawingContext(gameContext.context, {\n      y: 5,\n      height,\n      padding,\n      label: 'New Game',\n      border: true,\n    })\n\n    const switchGame = getLabelDrawingContext(gameContext.context, {\n      y: 5,\n      height,\n      padding,\n      label: `Switch to ${ScoringType[otherGameType]}`,\n      border: true,\n    })\n\n    const score = getLabelDrawingContext(gameContext.context, {\n      y: 5,\n      height,\n      padding,\n      label: `Score: ${currentScore}`,\n      border: false,\n    })\n\n    const version = getLabelDrawingContext(gameContext.context, {\n      height,\n      padding,\n      label: process.env.version || '',\n      border: false,\n    })\n\n    newGame.box.x = lightSwitch.box.x + lightSwitch.box.width\n    switchGame.box.x = newGame.box.x + newGame.box.width\n    score.box.x = gameContext.context.width - score.box.width\n    version.box.x = gameContext.context.width - version.box.width\n    version.box.y = gameContext.context.height - version.box.height\n\n    return { lightSwitch, newGame, switchGame, score, version }\n  }, [gameContext, currentScore, otherGameType])\n\n  const handleNewGame = React.useCallback(() => dispatch(initialize()), [dispatch])\n\n  const handleSwitchGame = React.useCallback(() => dispatch(initialize(otherGameType)), [dispatch, otherGameType])\n\n  useDrawing((context) => deets && drawLabel(context, deets.lightSwitch), { onClick: handleThemeChange })\n\n  useDrawing((context) => deets && drawLabel(context, deets.newGame), { onClick: handleNewGame })\n\n  useDrawing((context) => deets && drawLabel(context, deets.switchGame), { onClick: handleSwitchGame })\n\n  useDrawing((context) => deets && drawLabel(context, deets.score))\n\n  useDrawing((context) => deets && drawLabel(context, deets.version))\n\n  return null\n}\n\nexport { TopBar }\nexport default React.memo(TopBar)\n","import { DrawRoutine, DrawingContext, Box } from './Common'\n\nimport { search, measureWidth } from './FontSize'\n\ntype LabelDrawingOpts = {\n  label: string\n  padding: number\n  x?: number\n  y?: number\n  height: number\n  border?: boolean\n}\n\ntype LabelDrawingContext = LabelDrawingOpts & {\n  box: Box\n  font: string\n}\n\nexport const getLabelDrawingContext = (context: DrawingContext, opts: LabelDrawingOpts): LabelDrawingContext => {\n  const isBigEnough = (_: number, boxHeight: number) => boxHeight > height\n  const { ctx } = context\n  const { x, y, height, label } = opts\n  const font = search(context.ctx, isBigEnough, label)\n  const width = measureWidth(ctx, font, label)\n  return {\n    ...opts,\n    box: { x: x ?? 0, y: y ?? 0, width: width + opts.padding * 2, height: height + opts.padding * 2 },\n    font,\n  }\n}\n\nexport const drawLabel: DrawRoutine<LabelDrawingContext> = (context, drawingOpts) => {\n  if (drawingOpts == null) return null\n  const { ctx } = context\n  const { font, box, label, padding, border } = drawingOpts\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(box.x, box.y, box.width, box.height)\n  ctx.closePath()\n  ctx.clip()\n\n  ctx.font = font\n  ctx.textAlign = 'left'\n  ctx.textBaseline = 'top'\n  ctx.fillText(label, box.x + padding, box.y + padding)\n\n  if (border) {\n    ctx.strokeStyle = context.colorScheme.buttonBorder\n    ctx.strokeRect(box.x, box.y, box.width, box.height)\n  }\n\n  ctx.restore()\n\n  const path = new Path2D()\n  path.rect(box.x, box.y, box.width, box.height)\n  path.closePath()\n\n  return { box, path }\n}\n"],"sourceRoot":""}